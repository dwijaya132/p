<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <meta name="mobile-web-app-capable" content="yes" />
    <link rel="manifest" href="./manifest.json" />
    <meta name="theme-color" content="#0066ff">
    <title>Baca Partitur</title>
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@1.*/css/pico.min.css">
    <style>
        /* standard UI blue for this file */
        :root {
            --ui-blue: #1e90ff;
        }

        /* --- Zoom slider / thumb --- */
        /* Target explicit IDs and common class names for safety */
        #zoomSlider,
        input[type="range"].zoom,
        .range.zoom,
        .zoom-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 180px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.06);
            /* subtle background so thumb stands out on white */
            outline: none;
            vertical-align: middle;
        }

        /* track fill (WebKit) - make the filled part of the track use the standard blue */
        #zoomSlider::-webkit-slider-runnable-track,
        input[type="range"].zoom::-webkit-slider-runnable-track {
            border-radius: 999px;
            background: linear-gradient(90deg, var(--ui-blue) 0%, var(--ui-blue) 100%);
            box-shadow: none;
        }

        /* thumb */
        #zoomSlider::-webkit-slider-thumb,
        input[type="range"].zoom::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            border-radius: 50%;
            background: var(--ui-blue);
            border: 2px solid rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 8px rgba(30, 144, 255, 0.16);
            cursor: pointer;
        }

        /* Firefox thumb */
        #zoomSlider::-moz-range-thumb,
        input[type="range"].zoom::-moz-range-thumb {
            border-radius: 50%;
            background: var(--ui-blue);
            border: 2px solid rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 8px rgba(30, 144, 255, 0.16);
        }

        /* Firefox track */
        #zoomSlider::-moz-range-track,
        input[type="range"].zoom::-moz-range-track {
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.06);
        }

        /* --- Zoom label / value --- */
        #zoomLabel,
        label[for="zoomSlider"],
        .zoom-value,
        .zoomLabel {
            color: var(--ui-blue);
            font-weight: 600;
            font-size: 13px;
            margin-left: 6px;
            vertical-align: middle;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.8);
            /* tiny lift on white */
        }

        /* If label sits inside a control row, make sure it is readable on white */
        .control-row {
            background: transparent;
        }

        /* --- #fileLabel reposition + styling (interactive) --- */
        #fileLabel {
            position: absolute !important;
            bottom: 2px !important;
            right: 2px !important;
            color: var(--ui-blue) !important;
            padding: 6px 10px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.06);
            pointer-events: auto;
            /* <-- changed: make clickable */
            cursor: pointer;
            z-index: 50;
        }


        #recTimer {
            position: absolute !important;
            bottom: 28px !important;
            right: 2px !important;
            font-size: 13px;
            /* color: var(--ui-blue); */
            /* background: rgba(255,255,255,0.92); */
        }

        /* If there is an icon or small filename trimming, keep it compact */
        #fileLabel .name {
            max-width: 480px;
            display: inline-block;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* --- Hide view button (common selectors included) --- */
        #viewButton,
        .view-button,
        .btn-view,
        .viewBtn {
            display: none !important;
        }

        /* --- Optional small responsive tweak so slider doesn't overflow small containers --- */
        @media (max-width: 420px) {

            #zoomSlider,
            input[type="range"].zoom {
                width: 120px;
            }
        }
    </style>

    <style>
        :root {
            --ui-gap: 8px;
            --state-pill-bg: rgba(0, 0, 0, 0.5);
            --state-pill-color: #fff;
            --accent: #0066ff;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: #0066ff;

        }

        /* make pages full screen */

        .page {
            position: fixed;
            /* full-screen layer */
            inset: 0;
            /* top:0; right:0; bottom:0; left:0 */
            height: calc(var(--vh, 1vh) * 100);
            /* robust: uses JS-set --vh */
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            overflow: hidden;
            /* prevent content from pushing height unexpectedly */
        }

        /* Top controls area — hidden (we use overlay buttons) */
        .controls {
            display: none;
            /* hidden as requested */
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            background: rgba(255, 255, 255, 0.02);
            padding: 8px;
            border-radius: 10px;
        }

        .controls .group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .controls label {
            font-size: 0.9rem;
            color: #cfe2ff;
        }

        .btn-primary {
            background: linear-gradient(180deg, var(--accent), #0047b3);
            color: white;
        }

        .btn {
            transition: transform 120ms ease, box-shadow 120ms ease;
        }

        .btn:active {
            transform: translateY(1px) scale(0.995);
            box-shadow: none;
        }

        /* Preview area fills remaining space */
        .preview-wrap {
            flex: 1 1 auto;
            display: block;
            position: relative;
            overflow: hidden;
            border-radius: 6px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.5));
        }

        .preview-canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            position: relative;
            overflow: hidden;
        }

        .preview-canvas img {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
            user-select: none;
            -webkit-user-drag: none;
            max-width: none;
        }

        /* Overlay small buttons (top-left) */
        .overlay-buttons {
            position: absolute;
            bottom: 5px;
            left: 5px;
            display: flex;
            gap: 8px;
            z-index: 50;
            pointer-events: auto;
        }

        .ov-btn {
            padding: 6px 8px;
            font-size: 0.82rem;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.55);
            color: #e8f1ff;
            border: 1px solid rgba(255, 255, 255, 0.06);
            min-width: 66px;
        }

        .ov-btn:active {
            transform: translateY(1px);
        }

        /* bottom controls fixed at bottom of setup page */
        .bottom-controls {
            position: fixed;
            left: 8px;
            right: 8px;
            bottom: env(safe-area-inset-bottom, 8px);
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 9999;
            pointer-events: auto;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.0), rgba(0, 0, 0, 0.06));
            padding: 6px 8px;
            border-radius: 8px;
        }

        /* small horizontal zoom slider */
        .zoom-slider {
            width: 120px;
            height: 34px;
            margin: 0;
            background: transparent;
        }

        .zoom-slider::-webkit-slider-runnable-track {
            height: 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.08);
        }

        .zoom-slider::-webkit-slider-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-top: -4px;
            background: #fff;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }

        .zoom-slider:focus {
            outline: none;
        }


        .view-controls {
            position: fixed;
            left: 8px;
            /* anchor to left */
            bottom: env(safe-area-inset-bottom, 8px);
            /* bottom */
            display: flex;
            justify-content: flex-start;
            /* no centering */
            align-items: center;
            gap: 8px;
            z-index: 55;
        }

        .view-controls .btn {
            min-width: auto;
            /* width = content */
            padding: 6px 10px;
            /* smaller button look */
            font-size: 0.82rem;
        }

        /* View page */
        .view-wrap {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: black;
        }

        .view-canvas {
            position: fixed;
            /* full-screen layer */
            inset: 0;
            /* top:0; right:0; bottom:0; left:0 */
            height: calc(var(--vh, 1vh) * 100);
            /* robust: uses JS-set --vh */
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            overflow: hidden;
            /* prevent content from pushing height unexpectedly */
        }

        .view-canvas img {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
            max-width: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        /* state pill */
        .state-pill {
            position: fixed;
            bottom: 8px;
            right: 12px;
            background: var(--state-pill-bg);
            color: var(--state-pill-color);
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 0.95rem;
            z-index: 60;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }

        .hint {
            position: absolute;
            bottom: 54px;
            right: 12px;
            z-index: 11;
            color: #c8d8ff;
            background: rgba(0, 0, 0, 0.35);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .timer-badge {
            display: inline-block;
            min-width: 48px;
            text-align: center;
            background: rgba(255, 255, 255, 0.06);
            color: #eaf2ff;
            padding: 6px 8px;
            border-radius: 8px;
            font-weight: 600;
        }

        .small-muted {
            font-size: 0.85rem;
            color: #aab9d9;
        }

        @media (orientation:landscape) {
            .controls {
                padding: 10px;
            }
        }


        /* side buttons centered vertically left/right (fixed to viewport) */
        .side-btn {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            padding: 10px 14px;
            z-index: 99999;
            background: rgba(0, 0, 0, 0.65);
            color: #eaf2ff;
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            font-weight: 700;
            white-space: nowrap;
            width: auto;
            min-width: 0;
            pointer-events: auto;
        }

        .side-right {
            right: 10px;
        }

        .side-left {
            left: 10px;
        }

        /* timer variants */
        .timer-badge.recording {
            background: rgba(200, 40, 40, 0.95);
            color: #fff;
        }

        .timer-badge.paused {
            background: rgba(255, 255, 255, 0.06);
            color: #eaf2ff;
        }

        .timer-badge.replay {
            background: rgba(18, 98, 200, 0.95);
            color: #fff;
        }

        #replayBlinkLine {
            background: #000;
            opacity: 1;
        }

        /* fade cover already inline-styled; optionally tune: */
        #replayFadeCover {
            pointer-events: none;
        }

        /* --- compact playback controls (small blue buttons, auto-width) --- */
        #overlayPBRew,
        #overlayPBFwd {
            background: transparent !important;
        }

        #overlayPause {
            width: 80px !important;
            height: 36px !important;
        }

        /* Settings editor modal (theme color: #3e7bd6) */
        #settingsModalBackdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #settingsModal {
            width: min(1000px, 96%);
            height: min(820px, 92%);
            background: #071127;
            /* dark base (matches app), textareas are styled below */
            border-radius: 10px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            border: 4px solid #3e7bd6;
            /* theme border */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            color: #eaf2ff;
        }

        #settingsModal textarea {
            flex: 1 1 auto;
            width: 100%;
            box-sizing: border-box;
            padding: 14px;
            font-family: monospace;
            font-size: 13px;
            background: #021225;
            color: #eaf2ff;
            border: none;
            outline: none;
            resize: none;
        }

        #settingsModal .modal-footer {
            display: flex;
            gap: 10px;
            padding: 12px;
            justify-content: flex-end;
            background: rgba(0, 0, 0, 0.06);
        }

        #settingsModal .btn {
            padding: 8px 14px;
            border-radius: 8px;
            border: none;
            font-weight: 700;
            cursor: pointer;
        }

        #settingsModal .btn-cancel {
            background: transparent;
            color: #eaf2ff;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        #settingsModal .btn-ok {
            background: #3e7bd6;
            /* theme color */
            color: white;
            box-shadow: 0 6px 16px rgba(62, 123, 214, 0.18);
        }



        /* ---------------- Load modal styles (theme #3e7bd6) ---------------- */
        #loadModalBackdrop,
        #urlModalBackdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .loadModal,
        .urlModal {
            width: min(760px, 96%);
            max-width: 920px;
            background: #071127;
            color: #eaf2ff;
            border-radius: 10px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            border: 4px solid #3e7bd6;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .loadModal .modal-header {
            padding: 12px 16px;
            font-weight: 800;
            font-size: 16px;
            display: flex;
            align-items: center;
            /* <- ensure vertical centering */
            justify-content: space-between;
            gap: 10px;
        }


        .loadModal .modal-body {
            padding: 18px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .loadModal .modal-actions {
            padding: 12px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            background: rgba(0, 0, 0, 0.04);
        }

        .loadModal .btn {
            padding: 10px 14px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700;
        }

        .btn-plain {
            background: transparent;
            color: #eaf2ff;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        .btn-primary {
            background: #3e7bd6;
            color: #fff;
            box-shadow: 0 8px 22px rgba(62, 123, 214, 0.15);
            border: none;
        }

        .loadModal .close-x {
            background: #ff3b3b;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            font-weight: 800;
            cursor: pointer;

            display: flex;
            /* <- center the "x" glyph */
            align-items: center;
            justify-content: center;
            padding: 0;
            font-size: 14px;
            line-height: 1;
        }

        .urlModal .row {
            padding: 16px;
        }

        .urlModal input[type="url"] {
            width: 100%;
            box-sizing: border-box;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            background: #021225;
            color: #eaf2ff;
            outline: none;
            font-family: inherit;
        }
    </style>
</head>

<body>
    <!-- Setup Page (full screen) -->
    <section id="setupPage" class="page" aria-label="Setup Page">
        <div class="controls" role="region" aria-label="Controls">
            <!-- Hidden top controls (kept for backward compatibility) -->
            <div class="group">
                <button id="btnLoad" class="btn">Load File</button>
                <label for="rememberFolder" style="margin-left:6px">Remember folder</label>
                <input type="checkbox" id="rememberFolder"
                    title="Allow remembering folder (uses File System Access API)">
            </div>

            <div class="group">
                <label>Duration (s)</label>
                <input id="inpDuration" type="number" min="0.1" value="15" step="0.1" />
            </div>
            <div class="group">
                <label>Delay (s)</label>
                <input id="inpDelay" type="number" min="0" value="1" step="0.1" />
            </div>
            <div class="group">
                <label>Y down %</label>
                <input id="inpYdown" type="number" min="0" max="100" value="100" step="1" />
            </div>

            <div class="group" style="margin-left:auto">
                <button id="btnRecord" class="btn btn-primary">Record</button>
                <button id="btnOpenView" class="btn">Open View</button>
            </div>
        </div>

        <div class="preview-wrap" id="previewWrap" style="margin-top:8px;">
            <div class="preview-canvas" id="previewCanvas">
                <img id="previewImg" alt="preview" src="" draggable="false" />

                <!-- center-right Next button (shown during recording) -->
                <button id="btnNext" class="side-btn side-right" hidden>Next</button>

                <!-- center-left Continue button (shown after Next) -->
                <button id="btnContinue" class="side-btn side-left" hidden>Continue</button>

                <!-- RECORD PROMPT (Add this inside #previewCanvas) -->
                <div id="recordPrompt" style="
                    position: absolute;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 99999;
                    background: rgba(0,0,0,0.78);
                    color: #fff;
                    padding: 12px 16px;
                    border-radius: 10px;
                    font-weight: 700;
                    display: none;
                    text-align: center;
                    max-width: 92%;
                    box-shadow: 0 8px 24px rgba(0,0,0,0.5);
                ">Please select row 1 then click "Continue"</div>

            </div>

        </div>

        <div class="bottom-controls">
            <!-- overlay small buttons -->
            <div class="overlay-buttons" id="overlayButtons">
                <button id="overlayLoad" class="ov-btn">Load</button>
                <button id="overlayRecord" class="ov-btn">Record</button>
                <button id="overlayReplay" class="ov-btn" hidden>Replay</button>
                <!-- STATIC playback controls (placed next to Replay) -->
                <button id="overlayPause" class="ov-btn compact-btn" hidden>Pause</button>

                <label id="overlayPBAuto"
                    style="display:none; align-items:center; gap:6px; margin-bottom: 15px; margin-left:6px;">
                    <input id="overlayAutoChk" type="checkbox" style="margin:0 4px 0 0;"> Auto
                </label>

                <button id="overlayPBRew" class="ov-btn compact-btn" hidden title="Slower">◀</button>
                <button id="overlayPBFwd" class="ov-btn compact-btn" hidden title="Faster">▶</button>


                <button id="overlayOpenView" class="ov-btn" hidden>View</button>
                <button id="overlayRotate" class="ov-btn" hidden>Rotate</button>
                <!-- Zoom slider placed next to View button -->
                <label id="zoomlabel" for="zoomSlider" class="small-muted"
                    style="margin:6px 6px 0 6px; font-size:0.82rem;">Zoom</label>
                <input id="zoomSlider" class="zoom-slider" type="range" min="0.25" max="4" step="0.01" value="1"
                    title="Zoom" />
            </div>

            <div style="margin-left:auto" class="small-muted" id="fileLabel">No file loaded</div>
            <div style="margin-left:8px" id="recTimer" class="timer-badge" aria-live="polite">0.0s</div>
            <button id="btnManage" class="btn" hidden>Manage saved files</button>
        </div>
    </section>

    <!-- View Page (full screen) -->
    <section id="viewPage" class="view-wrap" aria-hidden="true">
        <div class="view-canvas" id="viewCanvas">
            <img id="viewImg" alt="view" src="" draggable="false" />
        </div>
        <div class="view-controls" id="viewControls">
            <button id="btnViewBack" class="btn">Back </button>
            <button id="btnViewToggle" class="btn btn-primary">Play</button>
            <div class="state-pill" id="statePill">Ready</div>
            <div class="hint" id="hint" hidden>Tap left/right when at end to move up/down</div>

        </div>
    </section>

    </section>


    <script>
        /* Partitur Reader — patched to requested behavior
           - Overlay small buttons: Load, Record, View, Rotate
           - Zoom slider removed
           - Rotation added (90° steps)
           - Record timestamps: touchRecordTime, firstPanTime, stopTime
           - View enters Paused state so user can position start
           - Resume logic: if hOffset ≈ startOffsetX then add delay, else compute remaining seconds using speed
        */

        // ======= Configuration =======
        const DB_NAME = 'scoreReaderDB';
        const STORE_FILES = 'files';
        const MAX_FILES = 300;
        const DEFAULTS = { duration: 15, delay: 1, ydownPercent: 100, zoom: 1.0 };

        // CONFIG: change these two IDs to your actual destination IDs on the server side
        const CLOUD_SHEET_ID = '1Ek-U11pOhKeSPN-IkSSDrSIKD2UvXsaFw7896l5qaLo';    // sheet used to store index / entries
        const CLOUD_SHEET_NAME = 'Sheet1';                     // (optional if server expects)
        const CLOUD_FOLDER_ID = '12yzR25U2Y3HQffoBNN2e949clHhK0qJ6'; // Drive folder where images are saved
        // ----- Replace with your deployed GAS web app URL (see GAS instructions below) -----
        const GAS_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyRMjOOoR3f9s2Zo9i7rBb8sQlNvwf8n1voiMlhNSDunZkGzjgEDZ5qoMA8T8WXgxzDYQ/exec'; // <-- set this


        // ======= Helpers =======
        function $(s, r = document) { return r.querySelector(s); }
        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
        function formatNumber(v) { return (Math.round(v * 100) / 100).toFixed(2); }
        function approxEqual(a, b, tol = 1) { return Math.abs(a - b) <= tol; }


        // ======= IndexedDB helpers (unchanged) =======
        function openDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(DB_NAME, 1);
                req.onupgradeneeded = e => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_FILES)) {
                        const s = db.createObjectStore(STORE_FILES, { keyPath: 'id' });
                        s.createIndex('lastUsed', 'lastUsed', { unique: false });
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function idbGet(id) {
            const db = await openDB(); return new Promise((res, rej) => {
                const tx = db.transaction(STORE_FILES, 'readonly'); const st = tx.objectStore(STORE_FILES);
                const r = st.get(id); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error);
            });
        }
        async function idbPut(rec) {
            const db = await openDB(); return new Promise((res, rej) => {
                const tx = db.transaction(STORE_FILES, 'readwrite'); const st = tx.objectStore(STORE_FILES);
                const r = st.put(rec); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error);
            });
        }
        async function idbDelete(id) {
            const db = await openDB(); return new Promise((res, rej) => {
                const tx = db.transaction(STORE_FILES, 'readwrite'); const st = tx.objectStore(STORE_FILES);
                const r = st.delete(id); r.onsuccess = () => res(); r.onerror = () => rej(r.error);
            });
        }
        async function pruneIfNeeded() {
            try {
                const db = await openDB(); const tx = db.transaction(STORE_FILES, 'readwrite'); const st = tx.objectStore(STORE_FILES);
                const idx = st.index('lastUsed'); const list = [];
                idx.openCursor().onsuccess = e => {
                    const cur = e.target.result; if (cur) { list.push({ id: cur.value.id, lastUsed: cur.value.lastUsed }); cur.continue(); } else {
                        if (list.length > MAX_FILES) { const removeCount = list.length - MAX_FILES; for (let i = 0; i < removeCount; i++) { st.delete(list[i].id); } }
                    }
                };
            } catch (e) { console.warn('prune failed', e); }
        }

        function fileIdFromFile(file) { if (!file) return null; return `${file.name}|${file.size}|${file.lastModified}`; }

        // ======= DOM refs =======
        const btnLoad = $('#btnLoad'), rememberFolder = $('#rememberFolder');
        const inpDuration = $('#inpDuration'), inpDelay = $('#inpDelay'), inpYdown = $('#inpYdown');
        const btnRecord = $('#btnRecord'), btnOpenView = $('#btnOpenView');
        const startLabel = $('#startLabel'), fileLabel = $('#fileLabel'), recTimer = $('#recTimer');
        const previewCanvas = $('#previewCanvas'), previewImg = $('#previewImg');
        const viewPage = $('#viewPage'), viewCanvas = $('#viewCanvas'), viewImg = $('#viewImg');
        const statePill = $('#statePill');
        const btnManage = $('#btnManage');
        const viewControls = $('#viewControls'), btnViewBack = $('#btnViewBack'), btnViewToggle = $('#btnViewToggle');

        // overlay buttons + zoom slider
        const overlayLoad = $('#overlayLoad'), overlayRecord = $('#overlayRecord'), overlayOpenView = $('#overlayOpenView'), overlayRotate = $('#overlayRotate');
        const zoomSlider = $('#zoomSlider');


        /* ---------- CLOUD: Save to cloud + Cloud list modal ---------- 
            Drop this code into the same <script> scope as your installLoadModal() code.
            It wires into the existing createLoadModal() via m.btnPrepared (Cloud).
        */


        // IndexedDB for cloud index (separate DB so we don't touch existing 'files' store)
        function openCloudDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open('cloudfileDB', 1);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('cloudfiles')) {
                        const s = db.createObjectStore('cloudfiles', { keyPath: 'id', autoIncrement: true });
                        s.createIndex('byFilename', 'filename', { unique: false });
                        s.createIndex('byDate', 'date', { unique: false });
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }
        async function cloudPut(rec) {
            const db = await openCloudDB();
            return new Promise((res, rej) => {
                const tx = db.transaction('cloudfiles', 'readwrite'), st = tx.objectStore('cloudfiles');
                const r = st.put(rec);
                r.onsuccess = () => res(r.result);
                r.onerror = () => rej(r.error);
            });
        }
        async function cloudClearAndPutAll(list) {
            const db = await openCloudDB();
            return new Promise((res, rej) => {
                const tx = db.transaction('cloudfiles', 'readwrite'), st = tx.objectStore('cloudfiles');
                // clear
                const clr = st.clear();
                clr.onsuccess = async () => {
                    try {
                        for (const it of list) {
                            // store as {date, filename, url, json}
                            await new Promise((r, j) => {
                                const p = st.add({ date: it[0], filename: it[1], url: it[2], json: it[3] });
                                p.onsuccess = () => r(p.result);
                                p.onerror = () => j(p.error);
                            });
                        }
                        res();
                    } catch (e) { rej(e); }
                };
                clr.onerror = () => rej(clr.error);
            });
        }
        async function cloudGetAll() {
            const db = await openCloudDB();
            return new Promise((res, rej) => {
                const tx = db.transaction('cloudfiles', 'readonly'), st = tx.objectStore('cloudfiles');
                const out = [];
                st.openCursor().onsuccess = e => {
                    const cur = e.target.result;
                    if (cur) { out.push(cur.value); cur.continue(); } else res(out);
                };
                st.openCursor().onerror = () => rej('cursor error');
            });
        }
        async function cloudFindByFilename(name) {
            const db = await openCloudDB();
            return new Promise((res, rej) => {
                const tx = db.transaction('cloudfiles', 'readonly'), st = tx.objectStore('cloudfiles');
                const idx = st.index('byFilename');
                const list = [];
                idx.openCursor().onsuccess = e => {
                    const cur = e.target.result;
                    if (cur) { if ((cur.value.filename || '').toLowerCase() === (name || '').toLowerCase()) list.push(cur.value); cur.continue(); } else res(list);
                };
                idx.openCursor().onerror = () => rej('cursor error');
            });
        }

        // helper convert image URL/objectURL to base64 (so we can send to GAS)
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const fr = new FileReader();
                fr.onload = () => resolve(fr.result.split(',', 2)[1]); // return base64 (strip data: prefix)
                fr.onerror = reject;
                fr.readAsDataURL(blob);
            });
        }
        async function urlOrObjectUrlToBase64(url) {
            console.log('Converting preview image to base64 for upload:', url);
            if (!url) throw new Error('No image url');
            // If it's an object URL (starts with blob:), fetch it normally
            const resp = await fetch(url, { method: 'GET', mode: 'cors' }).catch(e => { throw e; });
            if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
            const blob = await resp.blob();
            const base64 = await blobToBase64(blob);
            return { base64, mime: blob.type || 'image/png', blob };
        }

        // Create Save-to-cloud modal
        function createSaveToCloudModal(defaultFileName) {
            const bd = document.createElement('div'); bd.id = 'saveCloudBackdrop';
            bd.style.position = 'fixed'; bd.style.inset = 0; bd.style.background = 'rgba(0,0,0,0.6)'; bd.style.zIndex = 1000001;
            const modal = document.createElement('div'); modal.className = 'loadModal';
            modal.style.maxWidth = '560px';
            const header = document.createElement('div'); header.className = 'modal-header';
            const title = document.createElement('div'); title.textContent = 'Save to Cloud';
            const btnX = document.createElement('button'); btnX.className = 'close-x'; btnX.textContent = '×';
            header.appendChild(title); header.appendChild(btnX);
            const body = document.createElement('div'); body.className = 'modal-body';
            const row = document.createElement('div'); row.style.width = '100%';
            const label = document.createElement('div'); label.textContent = 'Filename / identifier'; label.style.marginBottom = '6px';
            const input = document.createElement('input'); input.type = 'text'; input.value = defaultFileName || ''; input.style.width = '100%';
            input.style.padding = '8px'; input.style.borderRadius = '6px'; input.style.background = '#021225'; input.style.color = '#eaf2ff';
            const underLabel = document.createElement('div'); underLabel.style.marginTop = '6px'; underLabel.style.height = '18px'; underLabel.style.color = '#ffb4b4';
            const waitNote = document.createElement('div'); waitNote.textContent = 'Checking cloud index...'; waitNote.style.fontSize = '0.9rem'; waitNote.style.marginTop = '8px';
            row.appendChild(label); row.appendChild(input); row.appendChild(underLabel); row.appendChild(waitNote);
            body.appendChild(row);
            const actions = document.createElement('div'); actions.className = 'modal-actions';
            const btnCancel = document.createElement('button'); btnCancel.className = 'btn btn-plain'; btnCancel.textContent = 'Cancel';
            const btnOK = document.createElement('button'); btnOK.className = 'btn btn-primary'; btnOK.textContent = 'OK'; btnOK.disabled = true;
            actions.appendChild(btnCancel); actions.appendChild(btnOK);
            modal.appendChild(header); modal.appendChild(body); modal.appendChild(actions); bd.appendChild(modal);

            btnX.addEventListener('click', () => { try { document.body.removeChild(bd); } catch (e) { } });
            btnCancel.addEventListener('click', () => { try { document.body.removeChild(bd); } catch (e) { } });

            return { backdrop: bd, input, underLabel, waitNote, btnOK, btnCancel };
        }

        // Create Cloud list (Load) modal (caption + input + search + select size=8 + Cancel/OK)
        function createCloudListModal() {
            const bd = document.createElement('div'); bd.id = 'cloudListBackdrop';
            bd.style.position = 'fixed'; bd.style.inset = 0; bd.style.background = 'rgba(0,0,0,0.6)'; bd.style.zIndex = 1000001;




            const modal = document.createElement('div'); modal.className = 'loadModal';
            modal.style.maxWidth = '720px';
            modal.style.width = 'min(720px, 96%)';
            modal.style.maxHeight = 'calc(100vh - 40px)';
            modal.style.display = 'flex';
            modal.style.flexDirection = 'column';
            modal.style.overflow = 'hidden';

            const header = document.createElement('div'); header.className = 'modal-header';
            const caption = document.createElement('div'); caption.textContent = 'Please wait...';
            const btnClose = document.createElement('button'); btnClose.className = 'close-x'; btnClose.textContent = '×';
            header.appendChild(caption); header.appendChild(btnClose);

            const body = document.createElement('div'); body.className = 'modal-body';
            body.style.boxSizing = 'border-box';
            body.style.flex = '1 1 auto';
            body.style.minHeight = '0';
            body.style.overflow = 'auto';

            // search input only (no separate Search button)
            const topRow = document.createElement('div');
            topRow.style.display = 'block';
            topRow.style.width = '100%';
            topRow.style.boxSizing = 'border-box';
            topRow.style.padding = '6px 8px';

            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = 'search filename...';
            searchInput.style.width = '100%';
            searchInput.style.boxSizing = 'border-box';
            searchInput.style.padding = '8px';
            searchInput.style.borderRadius = '6px';
            searchInput.style.border = '1px solid rgba(100,100,100,0.15)';
            // high-contrast text (theme blue)
            searchInput.style.color = '#ffffff';
            searchInput.style.background = '#021225';
            searchInput.style.fontSize = '1rem';

            topRow.appendChild(searchInput);

            const listbox = document.createElement('select');
            // size will be computed dynamically so we don't hardcode it here
            listbox.style.width = '100%';
            listbox.style.marginTop = '12px';
            listbox.style.boxSizing = 'border-box';
            listbox.style.maxWidth = '100%';
            // ensure select shows a scrollbar when size is set by JS
            listbox.style.overflowY = 'auto';

            body.appendChild(topRow); body.appendChild(listbox);

            const actions = document.createElement('div'); actions.className = 'modal-actions';
            actions.style.flex = '0 0 auto';
            const btnCancel = document.createElement('button'); btnCancel.className = 'btn btn-plain'; btnCancel.textContent = 'Cancel';
            const btnOK = document.createElement('button'); btnOK.className = 'btn btn-primary'; btnOK.textContent = 'OK';
            actions.appendChild(btnCancel); actions.appendChild(btnOK);

            // function to compute listbox.size based on available vertical room (between header, topRow, actions)
            function adjustListSize() {
                try {
                    const modalRect = modal.getBoundingClientRect();
                    const headerH = header.getBoundingClientRect().height || 48;
                    const topH = topRow.getBoundingClientRect().height || 56;
                    const actionsH = actions.getBoundingClientRect().height || 56;
                    // available height inside modal for the listbox (leave 8px breathing room)
                    const available = Math.max(0, modalRect.height - headerH - topH - actionsH - 8);
                    const optionHeight = 28; // approximate per-row height
                    const calc = Math.max(1, Math.min(8, Math.floor(available / optionHeight)));
                    listbox.size = calc;
                } catch (e) {
                    // ignore
                }
            }

            // Observe when backdrop is attached to DOM so we can measure actual sizes
            const mo = new MutationObserver((mutations, obs) => {
                if (document.body.contains(bd)) {
                    requestAnimationFrame(adjustListSize);
                    window.addEventListener('resize', adjustListSize);
                    obs.disconnect();
                }
            });
            mo.observe(document.body, { childList: true, subtree: true });










            modal.appendChild(header); modal.appendChild(body); modal.appendChild(actions); bd.appendChild(modal);

            function cleanupCloudList() {
                try { window.removeEventListener('resize', adjustListSize); } catch (e) {}
                try { mo.disconnect(); } catch (e) {}
                try { if (bd.parentNode) bd.parentNode.removeChild(bd); } catch (e) {}
            }
            btnClose.addEventListener('click', cleanupCloudList);
            btnCancel.addEventListener('click', cleanupCloudList);

            return { backdrop: bd, caption, searchInput, listbox, btnOK, btnCancel };
        }




        // We also create a global function to open the Save-to-Cloud modal programmatically:
        async function openSaveToCloudModal() {
            const defaultName = (currentFile && currentFile.name) ? currentFile.name : (fileLabel && fileLabel.textContent) || 'unnamed.png';
            const s = createSaveToCloudModal(defaultName);
            document.body.appendChild(s.backdrop);

            // mark we are fetching cloud index
            s.waitNote.textContent = 'Please wait — syncing cloud index...';
            console.log('[SaveCloud] opened, requesting index from server');

            // request index from server (server function1)
            // google.script.run.withSuccessHandler(async (rows) => {
            //     try {
            //         console.log('[SaveCloud] server returned rows count=', (rows && rows.length) ? rows.length : 0);
            //         await cloudClearAndPutAll(rows).catch(e => console.warn('[SaveCloud] cloudClearAndPutAll failed', e));
            //         s.waitNote.textContent = 'Ready. Enter a filename.';
            //         // initial check for defaultName
            //         const exists = (await cloudFindByFilename(s.input.value || '') || []).length > 0;
            //         s.btnOK.disabled = !!exists;
            //         s.underLabel.textContent = exists ? 'filename already exist' : '';
            //     } catch (err) {
            //         console.error('[SaveCloud] populate failed', err);
            //         s.waitNote.textContent = 'Index load failed';
            //     }
            // }).withFailureHandler((err) => {
            //     console.error('[SaveCloud] fetchCloudIndex failed', err);
            //     s.waitNote.textContent = 'Index load failed';
            // }).fetchCloudIndex(CLOUD_SHEET_ID, CLOUD_SHEET_NAME);
            // --- fetch index from GAS (POST) ---
            (async () => {
                try {
                    const payload = JSON.stringify({
                        action: 'fetchIndex',
                        sheetId: CLOUD_SHEET_ID,
                        sheetName: CLOUD_SHEET_NAME
                    });
                    const resp = await fetch(GAS_WEB_APP_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'text/plain' }, // "simple" content-type -> avoids preflight
                        body: payload,
                        // mode: 'cors' // default; no need to change
                    });
                    if (!resp.ok) throw new Error('Network response not ok: ' + resp.status);
                    const rows = await resp.json(); // expected: array of [date, filename, url, json]
                    try {
                        console.log('[SaveCloud] server returned rows count=', (rows && rows.length) ? rows.length : 0);
                        await cloudClearAndPutAll(rows).catch(e => console.warn('[SaveCloud] cloudClearAndPutAll failed', e));
                        s.waitNote.textContent = 'Ready. Enter a filename.';
                        const exists = (await cloudFindByFilename(s.input.value || '') || []).length > 0;
                        s.btnOK.disabled = !!exists;
                        s.underLabel.textContent = exists ? 'filename already exist' : '';
                    } catch (err) {
                        console.error('[SaveCloud] populate failed', err);
                        s.waitNote.textContent = 'Index load failed';
                    }
                } catch (err) {
                    console.error('[SaveCloud] fetchCloudIndex failed', err);
                    s.waitNote.textContent = 'Index load failed';
                }
            })();





            // live check when user edits filename
            s.input.addEventListener('input', async (e) => {
                const name = (s.input.value || '').trim();
                s.underLabel.textContent = '';
                s.btnOK.disabled = true;
                if (!name) { s.underLabel.textContent = 'Please enter a filename'; return; }
                console.log('[SaveCloud] checking file existence for', name);
                const list = await cloudFindByFilename(name).catch(e => { console.warn(e); return []; });
                if (list && list.length) {
                    s.underLabel.textContent = 'filename already exist';
                    s.btnOK.disabled = true;
                } else {
                    s.underLabel.textContent = '';
                    s.btnOK.disabled = false;
                }
            });

            // OK -> read current idb record and image, send to server save function
            s.btnOK.addEventListener('click', async () => {
                try {
                    s.btnOK.disabled = true;
                    s.waitNote.textContent = 'Preparing data...';
                    console.log('[SaveCloud] OK clicked, gathering record');
                    if (!fileId) { alert('No file loaded'); s.btnOK.disabled = false; return; }
                    const rec = await idbGet(fileId).catch(e => { console.warn(e); return null; });
                    if (!rec) { alert('No local record found for this file'); s.btnOK.disabled = false; return; }
                    const jsonStr = JSON.stringify(rec);
                    // image: prefer object URL if available, else previewImg.src
                    const imgSrc = currentObjectURL || (previewImg && previewImg.src) || null;
                    if (!imgSrc) { alert('No preview image found'); s.btnOK.disabled = false; return; }
                    s.waitNote.textContent = 'Converting image...';
                    const { base64, mime } = await urlOrObjectUrlToBase64(imgSrc);
                    console.log('[SaveCloud] image converted, size base64=', (base64 || '').length);
                    s.waitNote.textContent = 'Uploading to server...';
                    // call server save function (server function to create Drive file and append row to sheet)
                    // google.script.run.withSuccessHandler((res) => {
                    //     try {
                    //         console.log('[SaveCloud] server save result', res);
                    //         if (res && res.ok) {
                    //             // store an index entry locally for convenience
                    //             cloudPut({ date: res.date || (new Date()).toISOString(), filename: s.input.value.trim(), url: res.fileUrl || '', json: jsonStr }).catch(e => console.warn(e));
                    //             // close modal
                    //             try { document.body.removeChild(s.backdrop); } catch (e) { }
                    //             // show momentary fileLabel notification (reuse approach used elsewhere)
                    //             const fl = document.getElementById('fileLabel');
                    //             if (fl) {
                    //                 const prev = fl.textContent;
                    //                 fl.style.color = '#3e7bd6';
                    //                 fl.textContent = 'Save successful';
                    //                 setTimeout(() => { fl.style.color = ''; fl.textContent = prev; }, 1300);
                    //             }
                    //         } else {
                    //             alert('Server save failed: ' + JSON.stringify(res || 'unknown'));
                    //         }
                    //     } catch (err) {
                    //         console.error('[SaveCloud] server handler error', err);
                    //         alert('Server save returned error: ' + err);
                    //     }
                    // }).withFailureHandler((err) => {
                    //     console.error('[SaveCloud] google.script.run.saveCloudEntry failed', err);
                    //     alert('Upload failed: ' + JSON.stringify(err));
                    // }).saveCloudEntry(CLOUD_SHEET_ID, CLOUD_FOLDER_ID, s.input.value.trim(), jsonStr, base64, mime);
                    try {
                    const payload = {
                        action: 'saveEntry',
                        sheetId: CLOUD_SHEET_ID,
                        sheetName: CLOUD_SHEET_NAME,
                        folderId: CLOUD_FOLDER_ID,
                        filename: s.input.value.trim(),
                        jsonStr: jsonStr,
                        base64: base64,
                        mime: mime
                    };
                    const resp = await fetch(GAS_WEB_APP_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'text/plain' }, // keep it a "simple" content-type
                        body: JSON.stringify(payload)
                    });
                    if (!resp.ok) {
                        const txt = await resp.text().catch(()=>null);
                        throw new Error('Network error: ' + resp.status + ' ' + (txt || ''));
                    }
                    const res = await resp.json();
                    console.log('[SaveCloud] server save result', res);
                    if (res && res.ok) {
                        // same success handling as before
                        cloudPut({ date: res.date || (new Date()).toISOString(), filename: s.input.value.trim(), url: res.fileUrl || '', json: jsonStr }).catch(e => console.warn(e));
                        try { document.body.removeChild(s.backdrop); } catch (e) { }
                        const fl = document.getElementById('fileLabel');
                        if (fl) {
                            const prev = fl.textContent;
                            fl.style.color = '#3e7bd6';
                            fl.textContent = 'Save successful';
                            setTimeout(() => { fl.style.color = ''; fl.textContent = prev; }, 1300);
                        }
                    } else {
                        alert('Server save failed: ' + JSON.stringify(res || 'unknown'));
                    }
                } catch (err) {
                    console.error('[SaveCloud] fetch save failed', err);
                    alert('Upload failed: ' + (err && err.message ? err.message : err));
                }



                } catch (err) {
                    console.error('[SaveCloud] OK flow failed', err);
                    alert('Save failed: ' + err);
                    s.btnOK.disabled = false;
                }
            });
        } // openSaveToCloudModal

        // Add Save-to-Cloud button only when called (and only if not present)
        function addSaveToCloudButtonToUI() {
            try {
                if (document.getElementById('overlaySaveCloud')) return; // already present
                const parent = document.getElementById('overlayButtons') || document.getElementById('controls') || document.body;
                const btn = document.createElement('button');
                btn.className = 'ov-btn';
                btn.id = 'overlaySaveCloud';
                btn.textContent = 'Save to Cloud';
                btn.title = 'Save current file to cloud';
                // optional styling (keeps theme)
                btn.style.marginLeft = '8px';
                btn.addEventListener('click', () => {
                    openSaveToCloudModal().catch(e => console.error('[SaveCloud] open failed', e));
                });
                parent.appendChild(btn);
                console.log('[UI] Save to Cloud button inserted');
            } catch (e) {
                console.warn('[UI] addSaveToCloudButtonToUI error', e);
            }
        }


        // ---------------- Load modal + Import-URL modal (improved) ----------------
        (function installLoadModal() {
            const THEME = '#3e7bd6';
            const overlayLoad = document.getElementById('overlayLoad') || document.querySelector('[data-action="load"]') || null;
            if (!overlayLoad) return; // nothing to wire

            // --- helper: temporarily suppress the next native file picker activation
            // This prevents label/input activation when we intercept the Load button click.
            function suppressNextFilePicker(timeout = 900) {
                function captureHandler(ev) {
                    // Only suppress real file input activations
                    const t = ev.target;
                    if (t && t.tagName && t.tagName.toLowerCase() === 'input' && t.type === 'file') {
                        // prevent native file dialog from opening
                        try { ev.stopImmediatePropagation(); ev.preventDefault(); } catch (e) { }
                        // remove capture listener immediately
                        document.removeEventListener('click', captureHandler, true);
                    }
                }
                // Use capture so this runs before any activation from a label or other handler.
                document.addEventListener('click', captureHandler, true);
                // Safety: remove after timeout to avoid lingering interception
                setTimeout(() => {
                    try { document.removeEventListener('click', captureHandler, true); } catch (e) { }
                }, timeout);
            }

            function createLoadModal() {
                const bd = document.createElement('div');
                bd.id = 'loadModalBackdrop';

                const modal = document.createElement('div');
                modal.className = 'loadModal';

                // header
                const header = document.createElement('div');
                header.className = 'modal-header';
                const title = document.createElement('div');
                title.textContent = 'Loading file..';
                title.style.fontSize = '15px';
                const btnX = document.createElement('button');
                btnX.className = 'close-x';
                btnX.title = 'Close';
                btnX.textContent = '×';
                header.appendChild(title);
                header.appendChild(btnX);

                // body with three buttons
                const body = document.createElement('div');
                body.className = 'modal-body';

                const btnOpenLocal = document.createElement('button');
                btnOpenLocal.className = 'btn btn-primary';
                btnOpenLocal.textContent = 'Open local file';

                const btnImportURL = document.createElement('button');
                btnImportURL.className = 'btn btn-plain';
                btnImportURL.textContent = 'Import URL';

                const btnPrepared = document.createElement('button');
                btnPrepared.className = 'btn btn-plain';
                btnPrepared.textContent = 'Cloud';

                body.appendChild(btnOpenLocal);
                body.appendChild(btnImportURL);
                body.appendChild(btnPrepared);

                // actions area
                const actions = document.createElement('div');
                actions.className = 'modal-actions';

                modal.appendChild(header);
                modal.appendChild(body);
                modal.appendChild(actions);
                bd.appendChild(modal);

                // close handlers
                btnX.addEventListener('click', () => { try { document.body.removeChild(bd); } catch (e) { } });
                bd.addEventListener('click', (ev) => { if (ev.target === bd) { try { document.body.removeChild(bd); } catch (e) { } } });

                return { backdrop: bd, btnOpenLocal, btnImportURL, btnPrepared, close: () => { try { document.body.removeChild(bd); } catch (e) { } } };
            }

            function createUrlModal(parentBackdrop) {
                const bd = document.createElement('div');
                bd.id = 'urlModalBackdrop';

                const modal = document.createElement('div');
                modal.className = 'urlModal';

                const header = document.createElement('div');
                header.className = 'modal-header';
                header.innerHTML = '<div>Import image from URL</div><div style="width:28px"></div>';

                const row = document.createElement('div');
                row.className = 'row';
                const input = document.createElement('input');
                input.type = 'url';
                input.placeholder = 'https://...';
                row.appendChild(input);

                const footer = document.createElement('div');
                footer.className = 'modal-actions';
                const btnBatal = document.createElement('button');
                btnBatal.className = 'btn btn-plain';
                btnBatal.textContent = 'Batal';
                const btnOK = document.createElement('button');
                btnOK.className = 'btn btn-primary';
                btnOK.textContent = 'OK';
                btnOK.style.background = THEME;
                footer.appendChild(btnBatal);
                footer.appendChild(btnOK);

                modal.appendChild(header);
                modal.appendChild(row);
                modal.appendChild(footer);
                bd.appendChild(modal);

                // handlers
                btnBatal.addEventListener('click', () => {
                    try { document.body.removeChild(bd); } catch (e) { }
                    // return to parent backdrop (which is still present)
                });

                // OK -> try fetch-first then fallback to <img> load
                btnOK.addEventListener('click', async () => {
                    const url = (input.value || '').trim();
                    if (!url) { alert('Please paste an URL'); return; }

                    // Basic URL sanity check
                    try { new URL(url); } catch (e) { alert('Invalid URL'); return; }

                    // Attempt 1: fetch image as blob -> create File -> reuse loadFile(file)
                    try {
                        const resp = await fetch(url, { method: 'GET', mode: 'cors' });
                        if (!resp.ok) throw new Error('HTTP ' + resp.status);
                        const ctype = resp.headers.get('content-type') || '';
                        if (!ctype.startsWith('image/')) throw new Error('URL does not point to an image (Content-Type: ' + ctype + ')');
                        const blob = await resp.blob();

                        // Derive a filename from the URL (fallback to 'imported-image')
                        let fileName = 'imported-image';
                        try { fileName = (new URL(url)).pathname.split('/').pop() || fileName; } catch (e) { }

                        // Create a File object so loadFile(...) receives the same shape as local files
                        const fileFromBlob = new File([blob], fileName, { type: blob.type || 'image/*', lastModified: Date.now() });

                        // Close modals (same UX as Open local file)
                        try { document.body.removeChild(bd); } catch (e) { }
                        try { if (parentBackdrop && parentBackdrop.parentNode) document.body.removeChild(parentBackdrop); } catch (e) { }

                        // Reuse your existing loadFile flow so everything is initialized exactly the same way.
                        await loadFile(fileFromBlob, null);
                        console.log('Image loaded via fetch and handed to loadFile():', url);
                        return;
                    } catch (fetchErr) {
                        // fetch failed (often CORS) — fall back to direct <img> load and apply initialization manually.
                        console.warn('Fetch attempt failed (likely CORS). Falling back to direct <img> load. Error:', fetchErr);
                    }

                    // Fallback path: set previewImg.src = url and mimic the post-load steps of loadFile()
                    try {
                        // create a pseudo-file so we have name/size/lastModified for id/storage
                        let pseudoName = 'imported-image';
                        try { pseudoName = (new URL(url)).pathname.split('/').pop() || pseudoName; } catch (e) { }

                        const pseudoFile = { name: pseudoName, size: 0, lastModified: Date.now() };

                        // set currentFile/fileId/fileHandle similar to loadFile
                        currentFile = pseudoFile;
                        fileHandle = null;
                        fileId = fileIdFromFile(pseudoFile);
                        fileLabel.textContent = pseudoFile.name || 'Imported URL';

                        // set image sources (preview + view + front duplicate)
                        previewImg.src = url;
                        viewImg.src = url;
                        try { previewImgFront.src = url; } catch (e) { }

                        // wait for decode (may fail silently) then compute dims and apply settings
                        await previewImg.decode().catch(() => { });
                        preview.imgW = previewImg.naturalWidth || previewImg.width || 1;
                        preview.imgH = previewImg.naturalHeight || previewImg.height || 1;

                        // container dims
                        const rect = previewCanvas.getBoundingClientRect();
                        preview.containerW = rect.width; preview.containerH = rect.height;

                        // default fit width zoom
                        const fitZoom = preview.containerW / preview.imgW;
                        preview.scale = clamp(fitZoom, 0.25, 4);
                        preview.hOffset = 0; preview.vOffset = 0;
                        preview.rotation = 0;
                        viewState.rotation = 0;

                        // try to load saved record/settings
                        const rec = await idbGet(fileId).catch(() => null);
                        if (rec && rec.settings) {
                            dbRecord = rec;
                            fileSettings = Object.assign(fileSettings, rec.settings);
                            inpDuration.value = fileSettings.duration || DEFAULTS.duration;
                            inpDelay.value = fileSettings.delay || DEFAULTS.delay;
                            inpYdown.value = fileSettings.ydownPercent || DEFAULTS.ydownPercent;
                            preview.scale = fileSettings.startZoom || fileSettings.zoom || preview.scale;
                            preview.hOffset = fileSettings.startOffsetX || 0;
                            preview.vOffset = fileSettings.startOffsetY || 0;
                            preview.rotation = fileSettings.rotation || 0;
                        } else {
                            inpDuration.value = fileSettings.duration;
                            inpDelay.value = fileSettings.delay;
                            inpYdown.value = fileSettings.ydownPercent;
                            fileSettings.startZoom = preview.scale;
                            fileSettings.startOffsetX = 0; fileSettings.startOffsetY = 0;
                            fileSettings.rotation = 0;
                        }

                        // apply transforms and UI
                        updatePreviewTransform(true);
                        const zs = $('#zoomSlider'); if (zs) zs.value = preview.scale;

                        // close modals (same UX)
                        try { document.body.removeChild(bd); } catch (e) { }
                        try { if (parentBackdrop && parentBackdrop.parentNode) document.body.removeChild(parentBackdrop); } catch (e) { }

                        // persist the pseudo-record (saveRecord() will early-return if currentFile is falsy, but we set currentFile above)
                        await saveRecord().catch(() => { });

                        console.log('Image loaded into preview via direct <img> fallback:', url);
                        return;
                    } catch (err) {
                        alert('Failed to load the image: ' + err);
                    }
                });


                // clicking outside closes just this modal (but returns to parent)
                bd.addEventListener('click', (ev) => { if (ev.target === bd) { try { document.body.removeChild(bd); } catch (e) { } } });

                return { backdrop: bd, input, btnOK, btnBatal };
            }

            // helper: try to find a file input and click it
            function triggerNativeFilePicker() {
                // look for common file input ids/selectors; fallback to first visible input[type=file]
                const selectors = ['input[type="file"]', '#fileInput', '#filePicker', '#openFile', '#fileElem', 'input[data-role="file"]'];
                for (const sel of selectors) {
                    const el = document.querySelector(sel);
                    if (el && el.tagName && el.tagName.toLowerCase() === 'input' && el.type === 'file') {
                        try { el.click(); return true; } catch (e) { /* ignore */ }
                    }
                }
                // fallback: any input[type=file]
                const fallback = document.querySelector('input[type="file"]');
                if (fallback) { try { fallback.click(); return true; } catch (e) { } }
                return false;
            }

            // show load modal when user clicks overlayLoad (prevent default original action)
            overlayLoad.addEventListener('click', function loaderClickHandler(ev) {
                // prevent the native activation: suppress the next file picker call so label/input won't pop
                try { ev.preventDefault && ev.preventDefault(); ev.stopPropagation && ev.stopPropagation(); } catch (e) { }
                suppressNextFilePicker(900); // short window to block the native file dialog that otherwise opens

                const m = createLoadModal();
                document.body.appendChild(m.backdrop);
                wireCloudPreparedButton(m); // attaches new Cloud behaviour

                // Open local file -> prefer showOpenFilePicker() / openFilePicker() and await it.
                // We keep a short delay so suppressNextFilePicker() has time to expire.
                m.btnOpenLocal.addEventListener('click', async () => {
                    try { document.body.removeChild(m.backdrop); } catch (e) { }

                    // small delay ensures suppression window expired; if not, give a tiny delay
                    setTimeout(async () => {
                        try {
                            // await the unified picker (works on modern browsers, falls back internally)
                            await openFilePicker();
                        } catch (err) {
                            // if openFilePicker() fails (or environment doesn't support it), fall back to prior behavior
                            console.warn('openFilePicker failed, falling back to native trigger:', err);
                            const ok = triggerNativeFilePicker();
                            if (!ok) {
                                // as last-resort, re-use original overlay behaviour to let page's native handler run
                                overlayLoad.removeEventListener('click', loaderClickHandler);
                                try { overlayLoad.click(); } catch (e) { /* ignore */ }
                                setTimeout(() => { overlayLoad.addEventListener('click', loaderClickHandler); }, 250);
                            }
                        }
                    }, 120);
                });


                // Import URL -> open small URL modal on top
                m.btnImportURL.addEventListener('click', () => {
                    const urlModal = createUrlModal(m.backdrop);
                    document.body.appendChild(urlModal.backdrop);
                    setTimeout(() => { try { urlModal.input.focus(); } catch (e) { } }, 60);
                });

                // Prepared List placeholder - closes modal for now
                m.btnPrepared.addEventListener('click', () => {
                    try { document.body.removeChild(m.backdrop); } catch (e) { }
                    console.log('Prepared List clicked (not implemented)');
                });







                //-------gdrive 








                // Wire-up: replace the simple placeholder handler on your existing m.btnPrepared / Cloud button
                // Find the existing createLoadModal code where m.btnPrepared has a listener. Replace that small handler with this wiring.
                // In your file, the original handler did:
                //   m.btnPrepared.addEventListener('click', () => { try { document.body.removeChild(m.backdrop); } catch (e) { } console.log('Prepared List clicked (not implemented)'); });
                // Replace with the code below (or add after it and remove the old one).

                function wireCloudPreparedButton(m /* the createLoadModal result */) {
                    m.btnPrepared.addEventListener('click', async () => {
                        try { console.log('[Cloud] button clicked - opening Cloud list'); } catch (e) { }
                        // open cloud list modal
                        const cloudModal = createCloudListModal();
                        document.body.appendChild(cloudModal.backdrop);
                        cloudModal.caption.textContent = 'Please wait...';
                        cloudModal.listbox.innerHTML = '';
                        cloudModal.searchInput.value = '';
                        cloudModal.searchInput.focus();

                        // Ask server for the cloud index (server function1)
                        console.log('[Cloud] requesting index from server', CLOUD_SHEET_ID);
                        // google.script.run.withSuccessHandler(async (rows) => {
                        //     try {
                        //         console.log('[Cloud] server returned index rows count=', (rows && rows.length) ? rows.length : 0, rows);
                        //         // rows expected as array of arrays: [[date, filename, url, json], ...]
                        //         // store them locally in IndexedDB 'cloudfiles'
                        //         await cloudClearAndPutAll(rows).catch(e => console.warn('[Cloud] cloudClearAndPutAll failed', e));
                        //         cloudModal.caption.textContent = 'Which file to load?';
                        //         // populate listbox (sorted by date desc)
                        //         const all = await cloudGetAll();
                        //         all.sort((a, b) => (b.date || '').localeCompare(a.date || ''));
                        //         cloudModal.listbox.innerHTML = '';
                        //         for (const it of all) {
                        //             const opt = document.createElement('option');
                        //             opt.value = it.url || '';
                        //             opt.textContent = `${it.filename} — ${it.date || ''}`;
                        //             cloudModal.listbox.appendChild(opt);
                        //         }
                        //     } catch (err) {
                        //         console.error('[Cloud] populate error', err);
                        //         cloudModal.caption.textContent = 'Error loading index';
                        //     }
                        // }).withFailureHandler((err) => {
                        //     console.error('[Cloud] fetchCloudIndex failed', err);
                        //     cloudModal.caption.textContent = 'Error loading index';
                        // }).fetchCloudIndex(CLOUD_SHEET_ID, CLOUD_SHEET_NAME);
                        // --- fetch index from GAS (POST) ---
                        // --- fetch index from GAS (POST) ---
                        (async () => {
                            try {
                                const payload = JSON.stringify({
                                    action: 'fetchIndex',
                                    sheetId: CLOUD_SHEET_ID,
                                    sheetName: CLOUD_SHEET_NAME
                                });
                                const resp = await fetch(GAS_WEB_APP_URL, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'text/plain' }, // "simple" content-type -> avoids preflight
                                    body: payload
                                });
                                if (!resp.ok) throw new Error('Network response not ok: ' + resp.status);
                                const rows = await resp.json(); // expected: array of [date, filename, url, json]
                                try {
                                    console.log('[Cloud] server returned rows count=', (rows && rows.length) ? rows.length : 0);
                                    await cloudClearAndPutAll(rows).catch(e => console.warn('[Cloud] cloudClearAndPutAll failed', e));
                                    // --- use the cloud list modal's caption (not s.waitNote) ---
                                    cloudModal.caption.textContent = 'Which file to load?';
                                    const all = await cloudGetAll();
                                    all.sort((a, b) => (b.date || '').localeCompare(a.date || ''));
                                    cloudModal.listbox.innerHTML = '';
                                    for (const it of all) {
                                        const opt = document.createElement('option');
                                        opt.value = it.url || '';
                                        opt.textContent = `${it.filename} — ${it.date || ''}`;
                                        cloudModal.listbox.appendChild(opt);
                                    }
                                    cloudModal.caption.textContent = all.length ? 'Pick a file' : 'No cloud files found';
                                } catch (err) {
                                    console.error('[Cloud] populate failed', err);
                                    cloudModal.caption.textContent = 'Index load failed';
                                }
                            } catch (err) {
                                console.error('[Cloud] fetchCloudIndex failed', err);
                                cloudModal.caption.textContent = 'Index load failed';
                            }
                        })();




                        // wire search button and input: filtering local 'cloudfiles'
                        async function applySearch() {
                            const q = (cloudModal.searchInput.value || '').trim().toLowerCase();
                            const all = await cloudGetAll();
                            const filtered = q ? all.filter(x => (x.filename || '').toLowerCase().includes(q)) : all;
                            filtered.sort((a, b) => (b.date || '').localeCompare(a.date || ''));
                            cloudModal.listbox.innerHTML = '';
                            for (const it of filtered) {
                                const opt = document.createElement('option');
                                opt.value = it.url || '';
                                opt.textContent = `${it.filename} — ${it.date || ''}`;
                                cloudModal.listbox.appendChild(opt);
                            }
                            cloudModal.caption.textContent = filtered.length ? 'Pick a file' : 'No results';
                        }

                        // replace previous search wiring with this:
                        cloudModal.searchInput.addEventListener('input', (e) => {
                            applySearch().catch(err => console.warn('[Cloud] applySearch error', err));
                        });


                        // ------------------- Cloud-specific loader (preserve cloud metadata into scoreReaderDB) -------------------
                        // Called from the cloud "OK" handler as: await loadFileFromCloud(file, res.filename);
                        async function loadFileFromCloud(file, cloudFilename) {
                            try {
                                // basic preview initialization (same behavior as loadFile's initial steps)
                                if (currentObjectURL) { URL.revokeObjectURL(currentObjectURL); currentObjectURL = null; }
                                currentFile = file;
                                fileHandle = null;
                                fileId = fileIdFromFile(file);
                                fileLabel.textContent = file.name || 'Unnamed file';
                                currentObjectURL = URL.createObjectURL(file);
                                previewImg.src = currentObjectURL;
                                viewImg.src = currentObjectURL;
                                try { previewImgFront.src = currentObjectURL; } catch (e) { /* ignore */ }

                                await previewImg.decode().catch(() => { /* ignore decode errors */ });

                                preview.imgW = previewImg.naturalWidth || 1;
                                preview.imgH = previewImg.naturalHeight || 1;
                                const rect = previewCanvas.getBoundingClientRect();
                                preview.containerW = rect.width; preview.containerH = rect.height;

                                // default fit width zoom
                                const fitZoom = preview.containerW / preview.imgW;
                                preview.scale = clamp(fitZoom, 0.25, 4);
                                preview.hOffset = 0; preview.vOffset = 0;
                                preview.rotation = 0;
                                viewState.rotation = 0;

                                // --- Step 1: delete any existing scoreReaderDB records whose id's filename equals cloudFilename
                                try {
                                    const db = await openDB();
                                    const tx = db.transaction(STORE_FILES, 'readwrite');
                                    const st = tx.objectStore(STORE_FILES);

                                    st.openCursor().onsuccess = function (e) {
                                        const cur = e.target.result;
                                        if (!cur) return; // finished
                                        const rec = cur.value || {};
                                        const recId = rec.id || '';
                                        const recFilename = (recId.split && recId.split('|')[0]) || '';
                                        if (recFilename === cloudFilename) {
                                            console.log('[CloudLoad] deleting existing scoreReaderDB record', recId);
                                            cur.delete();
                                        }
                                        cur.continue();
                                    };

                                    await new Promise((resolve, reject) => {
                                        tx.oncomplete = () => resolve();
                                        tx.onerror = () => reject(tx.error || new Error('tx error'));
                                        tx.onabort = () => reject(tx.error || new Error('tx abort'));
                                    });
                                } catch (err) {
                                    console.warn('[CloudLoad] could not delete existing records:', err);
                                }

                                // --- Step 2: import the cloud entry's json into scoreReaderDB (if present)
                                let importedParsed = null;
                                try {
                                    const matches = await cloudFindByFilename(cloudFilename); // returns array of cloudfile entries
                                    if (matches && matches.length) {
                                        // choose the first match (you can refine selection by url if you pass it)
                                        const cloudEntry = matches[0];
                                        if (cloudEntry && cloudEntry.json) {
                                            let parsed = cloudEntry.json;
                                            if (typeof parsed === 'string') {
                                                try { parsed = JSON.parse(parsed); } catch (e) { parsed = null; }
                                            }
                                            if (parsed && parsed.id) {
                                                // write exactly the stored record object into scoreReaderDB
                                                await idbPut(parsed);
                                                importedParsed = parsed;
                                                console.log('[CloudLoad] imported cloud metadata -> scoreReaderDB id=', parsed.id);
                                            } else {
                                                console.warn('[CloudLoad] cloud json missing required id for', cloudFilename);
                                            }
                                        } else {
                                            console.log('[CloudLoad] no json metadata found in cloud entry for', cloudFilename);
                                        }
                                    } else {
                                        console.log('[CloudLoad] no cloud DB entry found for', cloudFilename);
                                    }
                                } catch (err) {
                                    console.warn('[CloudLoad] error importing cloud metadata:', err);
                                }

                                // --- Step 2.5: if we imported a parsed record, align in-memory identity to it BEFORE calling saveRecord()
                                if (importedParsed && importedParsed.id) {
                                    try {
                                        // parsed.id is like "filename|size|lastModified"
                                        const parts = (importedParsed.id || '').split('|');
                                        const parsedName = parts[0] || cloudFilename;
                                        const parsedSize = Number(parts[1]) || (importedParsed.size || 0);
                                        const parsedLast = Number(parts[2]) || (importedParsed.lastModified || Date.now());

                                        // replace fileId so saveRecord writes to the same key
                                        fileId = importedParsed.id;

                                        // ensure currentFile metadata matches parsed values so saveRecord won't generate a different id
                                        // (we keep currentObjectURL for the preview created above)
                                        currentFile = { name: parsedName, size: parsedSize, lastModified: parsedLast };

                                        // make the in-memory DB pointers consistent
                                        dbRecord = importedParsed;
                                        fileSettings = Object.assign({}, importedParsed.settings || {});
                                        // update inputs from fileSettings
                                        try {
                                            inpDuration.value = fileSettings.duration || DEFAULTS.duration;
                                            inpDelay.value = fileSettings.delay || DEFAULTS.delay;
                                            inpYdown.value = fileSettings.ydownPercent || DEFAULTS.ydownPercent;
                                            preview.scale = fileSettings.startZoom || fileSettings.zoom || preview.scale;
                                            preview.hOffset = fileSettings.startOffsetX || 0;
                                            preview.vOffset = fileSettings.startOffsetY || 0;
                                            preview.rotation = fileSettings.rotation || 0;
                                        } catch (e) { /* ignore UI update failures */ }

                                        console.log('[CloudLoad] aligned in-memory identity to imported cloud id=', fileId);
                                    } catch (err) {
                                        console.warn('[CloudLoad] alignment to imported id failed:', err);
                                    }
                                } else {
                                    // no importedParsed -> leave currentFile/fileId as-is (the freshly-created File)
                                }

                                // --- Step 3: try to load the (now-aligned) scoreReaderDB record and apply settings (safe fallback)
                                try {
                                    const rec = await idbGet(fileId).catch(() => null);
                                    if (rec && rec.settings) {
                                        dbRecord = rec;
                                        fileSettings = Object.assign({}, fileSettings || {}, rec.settings);
                                        inpDuration.value = fileSettings.duration || DEFAULTS.duration;
                                        inpDelay.value = fileSettings.delay || DEFAULTS.delay;
                                        inpYdown.value = fileSettings.ydownPercent || DEFAULTS.ydownPercent;
                                        preview.scale = fileSettings.startZoom || fileSettings.zoom || preview.scale;
                                        preview.hOffset = fileSettings.startOffsetX || 0;
                                        preview.vOffset = fileSettings.startOffsetY || 0;
                                        preview.rotation = fileSettings.rotation || 0;
                                    } else {
                                        // leave current in-memory settings as-is (fallback)
                                    }
                                } catch (err) {
                                    console.warn('[CloudLoad] failed to apply scoreReaderDB record:', err);
                                }

                                // --- Step 4: persist new/merged record like loadFile would (this will now update the imported record instead of
                                // creating a new one because we set fileId to the importedParsed.id above)
                                try {
                                    if (typeof saveRecord === 'function') {
                                        await saveRecord();
                                        
                                        addSaveToCloudButtonToUI();  // <- call this here so the button appears only after successful image load

                                        // to show Replay only when the imported record actually has segments + initials,                                        
                                        const _or = document.getElementById('overlayReplay');
                                        if (_or) {
                                            _or.hidden = !(fileSettings && fileSettings.segments && fileSettings.segments.length
                                                        && fileSettings.initials && fileSettings.initials.length);
                                        }

                                    }
                                } catch (err) {
                                    console.warn('[CloudLoad] saveRecord failed:', err);
                                }

                                console.log('[CloudLoad] completed for', cloudFilename);
                            } catch (err) {
                                console.error('[CloudLoad] unexpected error:', err);
                            }
                        }
                        


                        // OK -> load selected file: call server to get blob/base64 for url then reuse loadFile(File)
                        cloudModal.btnOK.addEventListener('click', async () => {
                            const sel = cloudModal.listbox.selectedOptions[0];
                            if (!sel) return alert('Please select a file');
                            const url = sel.value;
                            console.log('[Cloud] Loading selected url:', url);
                            cloudModal.caption.textContent = 'Fetching file...';
                            // call server to get base64 (server function2)
                            // google.script.run.withSuccessHandler(async (res) => {
                            //     try {
                            //         // res = { base64, mime, filename }
                            //         if (!res || !res.base64) throw new Error('No data returned');
                            //         const bin = atob(res.base64);
                            //         const len = bin.length;
                            //         const ab = new Uint8Array(len);
                            //         for (let i = 0; i < len; i++) ab[i] = bin.charCodeAt(i);
                            //         const blob = new Blob([ab.buffer], { type: res.mime || 'image/png' });
                            //         const file = new File([blob], res.filename || 'cloud-image', { type: res.mime || 'image/png', lastModified: Date.now() });
                            //         // close modal & parent (if any)
                            //         try { document.body.removeChild(cloudModal.backdrop); } catch (e) { }
                            //         try { if (m && m.backdrop) document.body.removeChild(m.backdrop); } catch (e) { }
                            //         // reuse your existing loadFile
                                    
                            //         await loadFileFromCloud(file, res.filename);
                                    

                            //         console.log('[Cloud] image loaded into preview via loadFile()');
                            //     } catch (err) {
                            //         console.error('[Cloud] processing returned blob failed', err);
                            //         alert('Failed to load cloud file: ' + err);
                            //     }
                            // }).withFailureHandler((err) => {
                            //     console.error('[Cloud] getDriveFileBase64 failed', err);
                            //     alert('Server fetch failed: ' + JSON.stringify(err));
                            // }).getDriveFileBase64(url);

                            // --- fetch drive file base64 via GAS ---
                            (async () => {
                                try {
                                    const payload = JSON.stringify({
                                        action: 'getDriveFileBase64',
                                        url: url // the same url variable you used before
                                    });
                                    const resp = await fetch(GAS_WEB_APP_URL, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'text/plain' }, // make it a "simple" request
                                        body: payload
                                    });
                                    if (!resp.ok) throw new Error('Network response not ok: ' + resp.status);
                                    const res = await resp.json(); // expected { ok:true, base64, mime, filename } or {ok:false, error}
                                    if (!res || !res.base64) throw new Error(res && res.error ? res.error : 'No data returned');

                                    // decode base64 -> blob -> File (same logic you had)
                                    const bin = atob(res.base64);
                                    const len = bin.length;
                                    const ab = new Uint8Array(len);
                                    for (let i = 0; i < len; i++) ab[i] = bin.charCodeAt(i);
                                    const blob = new Blob([ab.buffer], { type: res.mime || 'image/png' });
                                    const file = new File([blob], res.filename || 'cloud-image', { type: res.mime || 'image/png', lastModified: Date.now() });

                                    // close modal & parent (if any)
                                    try { document.body.removeChild(cloudModal.backdrop); } catch (e) { /* ignore */ }
                                    try { if (m && m.backdrop) document.body.removeChild(m.backdrop); } catch (e) { /* ignore */ }

                                    // reuse existing loader
                                    await loadFileFromCloud(file, res.filename);

                                    console.log('[Cloud] image loaded into preview via loadFile()');
                                } catch (err) {
                                    console.error('[Cloud] getDriveFileBase64 fetch failed', err);
                                    alert('Server fetch failed: ' + (err && err.message ? err.message : err));
                                }
                            })();

                        });

                    });
                } // wireCloudPreparedButton

                // Now add a handler for Save-to-Cloud button. We'll create it and attach to page header or to load modal area.
                // For convenience, we'll add a small 'Save to Cloud' button inside the load modal, next to your existing 'Cloud' button.
                // Find where createLoadModal() returns m with btnPrepared (Cloud). When you append the modal to the DOM, call this
                // wireCloudPreparedButton(m); so that clicking Cloud opens our cloud list and Save to Cloud features.

                // Example small injector: after your createLoadModal() call (where you have `const m = createLoadModal(); document.body.appendChild(m.backdrop);`)
                // add the following line:
                //     wireCloudPreparedButton(m);









                //-----end of gdrive












            }, { passive: false });

        })();


        // ------------------------ Settings editor modal (double-click/tap on #fileLabel) ------------------------
        // Adds a modal that shows the JSON of `rec.settings` for the current fileId.
        // User can edit and press "OK" to persist back to IndexedDB (and update in-memory fileSettings).

        (function installFileLabelSettingsEditor() {
            const THEME = '#3e7bd6';

            // helper: create modal DOM
            function createSettingsModal(initialJson) {
                // backdrop
                const bd = document.createElement('div');
                bd.id = 'settingsModalBackdrop';

                // modal container
                const m = document.createElement('div');
                m.id = 'settingsModal';

                // textarea
                const ta = document.createElement('textarea');
                ta.spellcheck = false;
                ta.value = initialJson;
                ta.style.padding = '12px';
                ta.style.fontSize = '13px';
                ta.style.lineHeight = '1.4';
                ta.style.overflow = 'auto';

                // footer with buttons
                const footer = document.createElement('div');
                footer.className = 'modal-footer';

                const btnCancel = document.createElement('button');
                btnCancel.type = 'button';
                btnCancel.className = 'btn btn-cancel';
                btnCancel.textContent = 'Batal';

                const btnOK = document.createElement('button');
                btnOK.type = 'button';
                btnOK.className = 'btn btn-ok';
                btnOK.textContent = 'OK';
                // apply theme color explicitly for safety
                btnOK.style.background = THEME;
                btnOK.style.border = 'none';
                btnOK.style.color = '#fff';

                footer.appendChild(btnCancel);
                footer.appendChild(btnOK);

                m.appendChild(ta);
                m.appendChild(footer);
                bd.appendChild(m);

                // Cancel handler -> remove modal
                btnCancel.addEventListener('click', () => {
                    try { document.body.removeChild(bd); } catch (e) { /* ignore */ }
                });


                // clicking backdrop outside the modal closes (same as cancel)
                // NOTE: add a tiny guard to ignore the immediate click produced by the same tap that opened the modal
                bd._createdAt = performance.now();
                bd.addEventListener('click', (ev) => {
                    // ignore accidental immediate clicks resulting from the tap that opened the modal
                    if (performance.now() - bd._createdAt < 220) return;
                    if (ev.target === bd) {
                        try { document.body.removeChild(bd); } catch (e) { /* ignore */ }
                    }
                });


                return { backdrop: bd, textarea: ta, btnOK, btnCancel };
            }

            // open the modal, load settings JSON from idb for current fileId
            async function openSettingsEditor() {
                if (!fileId) {
                    alert('Tidak ada file ter-load (No file loaded).');
                    return;
                }

                // fetch record
                let rec = null;
                try {
                    rec = await idbGet(fileId).catch(() => null);
                } catch (e) { rec = null; }

                // default to in-memory fileSettings if no saved record exists
                const curSettings = (rec && rec.settings) ? rec.settings : (typeof fileSettings !== 'undefined' ? fileSettings : {});
                const pretty = JSON.stringify(curSettings, null, 2);

                // create & show modal
                const modal = createSettingsModal(pretty);
                document.body.appendChild(modal.backdrop);
                // focus textarea and select to make editing convenient
                modal.textarea.focus();
                modal.textarea.setSelectionRange(0, 0);

                // OK handler: parse and save into IndexedDB
                modal.btnOK.addEventListener('click', async () => {
                    const txt = modal.textarea.value;
                    let parsed;
                    try {
                        parsed = JSON.parse(txt);
                    } catch (err) {
                        alert('JSON tidak valid — periksa kembali. (Invalid JSON)\\n' + err);
                        return;
                    }

                    try {
                        // if no record exists, create a minimal wrapper record
                        if (!rec) {
                            const newRec = {
                                id: fileId,
                                name: (currentFile && currentFile.name) ? currentFile.name : (fileLabel && fileLabel.dataset && fileLabel.dataset.orig ? fileLabel.dataset.orig : 'Unknown'),
                                size: (currentFile && currentFile.size) ? currentFile.size : 0,
                                lastModified: (currentFile && currentFile.lastModified) ? currentFile.lastModified : Date.now(),
                                handle: fileHandle || null,
                                settings: parsed,
                                lastUsed: Date.now()
                            };
                            await idbPut(newRec);
                            rec = newRec;
                        } else {
                            // update only settings field so we don't accidentally wipe other metadata
                            rec.settings = parsed;
                            rec.lastUsed = Date.now();
                            await idbPut(rec);
                        }

                        // Update in-memory fileSettings so UI immediately reflects change
                        try {
                            fileSettings = Object.assign({}, fileSettings || {}, parsed);
                        } catch (e) { /* ignore */ }

                        // Save current record too (saveRecord will persist other runtime props such as rotation)
                        try { if (typeof saveRecord === 'function') await saveRecord(); } catch (e) { /* ignore */ }

                        // remove modal
                        try { document.body.removeChild(modal.backdrop); } catch (e) { /* ignore */ }

                        // small visual confirmation
                        const fl = document.getElementById('fileLabel');
                        if (fl) {
                            const prev = fl.textContent;
                            fl.style.color = THEME;
                            fl.textContent = 'Settings saved';
                            setTimeout(() => { fl.style.color = ''; fl.textContent = prev; }, 1100);
                        }
                    } catch (err) {
                        alert('Gagal menyimpan ke IndexedDB: ' + err);
                    }
                });
            }

            // wire dblclick (mouse) and double-tap (touch) on #fileLabel
            const fl = document.getElementById('fileLabel');
            if (!fl) return;

            // mouse dblclick
            fl.addEventListener('dblclick', (e) => {
                e.preventDefault();
                openSettingsEditor();
            });

            // pointerdown-based double-tap detection for touch devices
            let lastTapFile = 0, lastTapFileX = 0, lastTapFileY = 0;
            const DOUBLE_MS = 350, MAX_MOVE_PX = 40;

            // NOTE: listener is explicitly non-passive so we may call preventDefault() safely.
            fl.addEventListener('pointerdown', (e) => {
                const now = performance.now();
                const x = e.clientX || 0, y = e.clientY || 0;
                if (now - lastTapFile < DOUBLE_MS && Math.hypot(x - lastTapFileX, y - lastTapFileY) < MAX_MOVE_PX) {
                    // double-tap detected
                    lastTapFile = 0;
                    // prevent the generated click from propagating and closing the modal
                    try { e.preventDefault(); } catch (err) { /* ignore */ }
                    e.stopPropagation();
                    openSettingsEditor();
                } else {
                    lastTapFile = now; lastTapFileX = x; lastTapFileY = y;
                }
            }, { passive: false });


        })();


        // --- front-layer image (duplicate) ---
        // Insert after the DOM refs where previewImg is declared.
        const previewImgFront = document.createElement('img');
        previewImgFront.id = 'previewImgFront';
        previewImgFront.alt = 'front';
        previewImgFront.draggable = false;
        previewImgFront.style.position = 'absolute';
        previewImgFront.style.top = '0';
        previewImgFront.style.left = '0';
        previewImgFront.style.transformOrigin = '0 0';
        previewImgFront.style.willChange = 'transform, clip-path';
        previewImgFront.style.pointerEvents = 'none'; // do not steal input
        previewImgFront.style.zIndex = '2'; // above previewImg
        previewImgFront.style.display = 'none'; // hidden until needed
        previewCanvas.appendChild(previewImgFront);

        // ensure the original back image sits beneath
        previewImg.style.zIndex = '1';


        // ======= App state =======
        let currentFile = null, fileHandle = null, fileId = null, currentObjectURL = null, dbRecord = null;


        let fileSettings = {
            startOffsetX: 0,
            startOffsetY: 0,
            startZoom: 1,
            duration: DEFAULTS.duration,
            delay: DEFAULTS.delay,
            ydownPercent: DEFAULTS.ydownPercent,
            zoom: DEFAULTS.zoom,
            // playback defaults — persisted to DB
            playbackspeed: 100,   // percent; 100 = normal
            autoplayback: false   // boolean
        };
        // preview state
        let preview = { scale: DEFAULTS.zoom, hOffset: 0, vOffset: 0, imgW: 0, imgH: 0, containerW: 0, containerH: 0, dragging: false, lastPointer: null, lockVertical: false, lockZoom: false, rotation: 0 };

        // view state
        let viewState = { scale: 1, hOffset: 0, vOffset: 0, imgW: 0, imgH: 0, containerW: 0, containerH: 0, D_x: 0, D_y: 0, startOffsetX: 0, startOffsetY: 0, startZoom: 1, duration: DEFAULTS.duration, delay: DEFAULTS.delay, ydownPercent: DEFAULTS.ydownPercent, state: 'Setup', playReqId: null, _playStartTimestamp: 0, _hOffsetAtPlayStart: 0, vx: 0, rotation: 0 };

        // record workflow state
        let recordState = { mode: 'idle', timerHandle: null, countdown: 0, startTime: 0, stopTime: 0, preVOffset: 0, _delayTick: null, touchRecordTime: 0, firstPanTime: 0 };

        // front reveal state: becomes true once front is revealed to half (50%)
        // and stays true until the user explicitly taps/clicks to continue
        let frontAwaitingTap = false;

        // ======= Load file handling =======
        async function loadFile(file, handle = null) {
            if (currentObjectURL) { URL.revokeObjectURL(currentObjectURL); currentObjectURL = null; }
            currentFile = file; fileHandle = handle; fileId = fileIdFromFile(file);
            fileLabel.textContent = file.name || 'Unnamed file';
            currentObjectURL = URL.createObjectURL(file);
            previewImg.src = currentObjectURL; viewImg.src = currentObjectURL;
            previewImgFront.src = currentObjectURL; // keep duplicate in sync

            await previewImg.decode().catch(() => { });
            preview.imgW = previewImg.naturalWidth || 1; preview.imgH = previewImg.naturalHeight || 1;
            // set container dims
            const rect = previewCanvas.getBoundingClientRect();
            preview.containerW = rect.width; preview.containerH = rect.height;
            // default fit width zoom
            const fitZoom = preview.containerW / preview.imgW;
            preview.scale = clamp(fitZoom, 0.25, 4);
            preview.hOffset = 0; preview.vOffset = 0;
            preview.rotation = 0;
            viewState.rotation = 0;
            // load saved record if any
            const rec = await idbGet(fileId).catch(() => null);
            if (rec && rec.settings) {
                dbRecord = rec;
                fileSettings = Object.assign(fileSettings, rec.settings);
                inpDuration.value = fileSettings.duration || DEFAULTS.duration;
                inpDelay.value = fileSettings.delay || DEFAULTS.delay;
                inpYdown.value = fileSettings.ydownPercent || DEFAULTS.ydownPercent;
                preview.scale = fileSettings.startZoom || fileSettings.zoom || preview.scale;
                preview.hOffset = fileSettings.startOffsetX || 0;
                preview.vOffset = fileSettings.startOffsetY || 0;
                preview.rotation = fileSettings.rotation || 0;
            } else {
                inpDuration.value = fileSettings.duration;
                inpDelay.value = fileSettings.delay;
                inpYdown.value = fileSettings.ydownPercent;
                fileSettings.startZoom = preview.scale;
                fileSettings.startOffsetX = 0; fileSettings.startOffsetY = 0;
                fileSettings.rotation = 0;
            }
            updatePreviewTransform(true);

            // ensure zoom slider shows current preview.scale
            const zs = $('#zoomSlider');
            if (zs) zs.value = preview.scale;

            // show Replay only when both segments AND initials exist for this file
            try {
                overlayReplay.hidden = !(fileSettings.segments && fileSettings.segments.length
                    && fileSettings.initials && fileSettings.initials.length);
            } catch (e) { /* ignore if overlayReplay not ready */ }

            saveRecord();

            // inside loadFile(file, ...) after image preview successfully set/shown:
            console.log('[loadFile] load successful for', file.name || file);
            addSaveToCloudButtonToUI();  // <- call this here so the button appears only after successful image load

        }

        async function saveRecord() {
            if (!currentFile) return;
            // capture current screen & preview image dimensions
            const screenW = window.innerWidth || document.documentElement.clientWidth || 0;
            const screenH = window.innerHeight || document.documentElement.clientHeight || 0;
            const imgW = preview.imgW || 0;
            const imgH = preview.imgH || 0;

            // ensure playback keys exist (defensive)
            if (typeof fileSettings.playbackspeed === 'undefined') fileSettings.playbackspeed = 100;
            if (typeof fileSettings.autoplayback === 'undefined') fileSettings.autoplayback = false;

            const rec = {
                id: fileId,
                name: currentFile.name,
                size: currentFile.size,
                lastModified: currentFile.lastModified,
                handle: fileHandle || null,
                // persist settings (includes playbackspeed & autoplayback)
                settings: Object.assign({}, fileSettings, { rotation: preview.rotation }),
                // store screen & image dims for later use
                screenW: screenW,
                screenH: screenH,
                imgW: imgW,
                imgH: imgH,
                lastUsed: Date.now()
            };
            await idbPut(rec).catch(e => console.warn('save fail', e));
            await pruneIfNeeded();
        }


        // ======= File pickers =======
        async function openFilePicker() {
            if (window.showOpenFilePicker) {
                try {
                    const [fh] = await window.showOpenFilePicker({ multiple: false, types: [{ description: 'Image files', accept: { 'image/*': ['.png', '.jpg', '.jpeg', '.webp', '.gif', '.bmp'] } }] });
                    if (!fh) return;
                    const f = await fh.getFile();
                    await loadFile(f, fh);
                    return;
                } catch (e) { console.warn('openFilePicker', e); }
            }
            // fallback
            const inp = document.createElement('input'); inp.type = 'file'; inp.accept = 'image/*';
            inp.onchange = async () => { if (inp.files && inp.files[0]) await loadFile(inp.files[0], null); };
            inp.click();
        }

        // ======= Preview interactions (pointer events) =======
        let activePointers = new Map();
        previewCanvas.addEventListener('pointerdown', (e) => {
            // ignore pointer interactions that originate from UI controls so they receive their own events
            // (buttons, inputs, overlay buttons, side buttons)
            if (e.target && e.target.closest && e.target.closest('button, input, select, textarea, .ov-btn, .side-btn')) {
                return;
            }

            if (isReplayActive()) return;

            // now, safe to capture pointer because this is a canvas interaction (not a control)
            previewCanvas.setPointerCapture(e.pointerId);
            activePointers.set(e.pointerId, e);


            if (activePointers.size === 1) {
                preview.dragging = true;
                preview.lastPointer = { x: e.clientX, y: e.clientY };
            } else if (activePointers.size === 2) {
                // prepare pinch base using the two active pointers
                const pts = Array.from(activePointers.values());
                preview._pinchBase = {
                    d: Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY),
                    scale: preview.scale
                };
            }
        });

        previewCanvas.addEventListener('pointermove', (e) => {
            // ignore any user input while replay is active
            if (isReplayActive()) return;

            // ignore pointer moves that came from UI controls (so dragging the button, etc., won't be treated as canvas drag)
            if (e.target && e.target.closest && e.target.closest('button, input, select, textarea, .ov-btn, .side-btn')) {
                return;
            }

            if (!activePointers.has(e.pointerId)) return;
            activePointers.set(e.pointerId, e);

            // SINGLE POINTER: dragging
            if (activePointers.size === 1 && preview.dragging) {
                const p = preview.lastPointer || { x: e.clientX, y: e.clientY };
                const dx = e.clientX - p.x;
                const dy = e.clientY - p.y;
                // update last pointer
                preview.lastPointer = { x: e.clientX, y: e.clientY };

                // apply horizontal always, vertical only if not locked
                // note: you previously used preview.hOffset = preview.hOffset - dx
                preview.hOffset = preview.hOffset - dx;
                // if vertical locked, ignore any vertical change
                if (!preview.lockVertical) {
                    preview.vOffset = preview.vOffset - dy;
                }

                // ensure vOffset does not go out of bounds (basic clamp)
                // compute vertical max (image height scaled minus container height)
                try {
                    const imgHeightScaled = ((preview.rotation % 180) !== 0 ? preview.imgW : preview.imgH) * preview.scale;
                    const maxV = Math.max(0, imgHeightScaled - preview.containerH);
                    preview.vOffset = clamp(preview.vOffset, 0, maxV);
                } catch (err) {
                    // if preview properties not ready, ignore
                }

                // Recording metadata: detect first meaningful horizontal pan
                if (recordState.mode === 'recording' && recordState.phase === 'captureSegments') {
                    if (!recordState.firstPanTime && Math.abs(dx) > 0.5) {
                        recordState.firstPanTime = performance.now();
                        recordState.firstPanHOffset = preview.hOffset;
                    }
                    recordState.lastPanHOffset = preview.hOffset;
                }


                updatePreviewTransform();
                return;
            }

            // TWO POINTERS: pinch-to-zoom
            if (activePointers.size === 2) {
                if (preview.lockZoom) return; // zoom locked during recording/replay as required
                const pts = Array.from(activePointers.values());
                const d = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
                const base = preview._pinchBase;
                if (base && base.d > 0) {
                    const sf = d / base.d;
                    preview.scale = clamp(base.scale * sf, 0.25, 4);
                    updatePreviewTransform();
                }
                return;
            }
        });

        previewCanvas.addEventListener('pointerup', (e) => {
            activePointers.delete(e.pointerId);
            try { previewCanvas.releasePointerCapture(e.pointerId); } catch (err) { }
            if (activePointers.size === 0) {
                preview.dragging = false;
                preview._pinchBase = null;
                preview.lastPointer = null;
            } else if (activePointers.size === 1) {
                // if one pointer left, reset lastPointer to the remaining pointer so movement continues smoothly
                const remaining = Array.from(activePointers.values())[0];
                preview.lastPointer = { x: remaining.clientX, y: remaining.clientY };
            }
        });


        previewCanvas.addEventListener('pointercancel', (e) => { activePointers.delete(e.pointerId); preview.dragging = false; preview._pinchBase = null; preview.lastPointer = null; });

        // compute scaled W/H based on rotation
        function scaledDimsForPreview() {
            const rot = ((preview.rotation % 360) + 360) % 360;
            const is90 = (rot === 90 || rot === 270);
            const scaledW = (is90 ? preview.imgH : preview.imgW) * preview.scale;
            const scaledH = (is90 ? preview.imgW : preview.imgH) * preview.scale;
            return { scaledW, scaledH };
        }

        function applyInitial(index) {
            if (!recordState.initials || index < 0 || index >= recordState.initials.length) return;
            const init = recordState.initials[index];
            preview.scale = (typeof init.scale !== 'undefined') ? init.scale : preview.scale;
            preview.hOffset = init.hOffset || 0;
            preview.vOffset = init.vOffset || 0;
            updatePreviewTransform();
        }

        // --- REC TIMER HELPERS (ADD) ---
        function _formatSec(s) {
            // format to 2 decimal seconds, e.g. "1.23s"
            return (Math.round(s * 100) / 100).toFixed(2) + 's';
        }

        function startRecTimer() {
            // stop any existing loop first
            stopRecTimer();
            recordState.recTimerRunning = true;
            function tick() {
                if (!recordState.recTimerRunning) return;
                const el = document.querySelector('#recTimer');
                if (!el) { recordState.recTimerRaf = requestAnimationFrame(tick); return; }

                let t = 0;
                // If capturing segments: before first pan -> show delay (now - startTime)
                // after first pan -> show duration (now - firstPanTime)
                if (recordState.phase === 'captureSegments') {
                    if (recordState.firstPanTime && recordState.firstPanTime > 0) {
                        t = (performance.now() - recordState.firstPanTime) / 1000;
                    } else if (recordState.startTime) {
                        t = (performance.now() - recordState.startTime) / 1000;
                    } else {
                        t = 0;
                    }
                } else {
                    // fallback: show time since startTime
                    if (recordState.startTime) t = (performance.now() - recordState.startTime) / 1000;
                }

                el.textContent = _formatSec(t);
                recordState.recTimerRaf = requestAnimationFrame(tick);
            }
            recordState.recTimerRaf = requestAnimationFrame(tick);
        }

        function stopRecTimer() {
            recordState.recTimerRunning = false;
            if (recordState.recTimerRaf) {
                cancelAnimationFrame(recordState.recTimerRaf);
                recordState.recTimerRaf = null;
            }
        }


        // update preview transform and ensure viewport never shows blank on right or left
        function updatePreviewTransform(skipClamp = false) {
            const rect = previewCanvas.getBoundingClientRect();
            preview.containerW = rect.width; preview.containerH = rect.height;
            const dims = scaledDimsForPreview();
            const scaledW = dims.scaledW;
            const scaledH = dims.scaledH;
            const D_x = Math.max(0, scaledW - preview.containerW);
            const D_y = Math.max(0, scaledH - preview.containerH);
            preview.hOffset = clamp(preview.hOffset, 0, D_x);
            preview.vOffset = clamp(preview.vOffset, 0, D_y);
            // apply transform: translate then rotate then scale
            previewImg.style.transform = `translate3d(${-Math.round(preview.hOffset)}px, ${-Math.round(preview.vOffset)}px, 0) rotate(${preview.rotation}deg) scale(${preview.scale})`;
        }

        // ======= Overlay button wiring (forward to existing handlers) =======
        overlayLoad.addEventListener('click', () => btnLoad.click());
        overlayRecord.addEventListener('click', () => btnRecord.click());
        overlayOpenView.addEventListener('click', () => btnOpenView.click());
        overlayRotate.addEventListener('click', () => {
            // rotate preview and view by +90°
            preview.rotation = (preview.rotation + 90) % 360;
            viewState.rotation = preview.rotation;
            // recompute offsets to clamp
            updatePreviewTransform(true);
            // apply rotation for view preview (if view open)
            if (viewPage.style.display === 'block') {
                // recalc view dims and apply
                const rect = viewCanvas.getBoundingClientRect();
                viewState.containerW = rect.width; viewState.containerH = rect.height;
                viewState.rotation = preview.rotation;
                enterView_recalcAndApply();
            }
            // persist in settings
            fileSettings.rotation = preview.rotation;
            saveRecord();
        });

        // --- Zoom slider wiring (if present) ---
        if (zoomSlider) {
            // initialize slider with current preview scale (or default)
            try { zoomSlider.value = (preview && preview.scale) ? preview.scale : (typeof DEFAULTS !== 'undefined' ? DEFAULTS.zoom : 1); } catch (e) { }

            // live update while dragging
            zoomSlider.addEventListener('input', (e) => {
                const val = Number(e.target.value) || 1;
                // keep within allowed range
                preview.scale = clamp ? clamp(val, 0.25, 4) : Math.max(0.25, Math.min(4, val));
                updatePreviewTransform();
            });

            // on change (mouseup / touchend) persist into fileSettings and save
            zoomSlider.addEventListener('change', (e) => {
                fileSettings.startZoom = Number(e.target.value) || preview.scale;
                if (typeof saveRecord === 'function') saveRecord();
            });
        }


        // file load button (both top hidden one and overlay forwarded)
        //btnLoad.addEventListener('click', async () => { await openFilePicker(); });

        // remember folder (same as before)
        rememberFolder.addEventListener('change', async () => {
            if (rememberFolder.checked && window.showDirectoryPicker) {
                try {
                    const dir = await window.showDirectoryPicker();
                    const rec = { id: 'DIR|' + (dir.name || 'unknown'), name: dir.name, handle: dir, settings: {}, lastUsed: Date.now() };
                    await idbPut(rec);
                    alert('Folder remembered.');
                } catch (err) { console.warn(err); rememberFolder.checked = false; alert('Could not remember folder.'); }
            }
        });

        // Manage saved files (simple prompt)
        btnManage.addEventListener('click', async () => {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_FILES, 'readonly'); const st = tx.objectStore(STORE_FILES);
                const items = []; st.openCursor().onsuccess = e => {
                    const cur = e.target.result; if (cur) { items.push(cur.value); cur.continue(); } else {
                        if (!items.length) return alert('No saved files');
                        const txt = items.map(it => `${it.id} (lastUsed: ${new Date(it.lastUsed).toLocaleString()})`).join('\\n');
                        const choice = prompt('Saved files:\\n\\n' + txt + '\\n\\nType exact id to delete or leave empty');
                        if (choice) { idbDelete(choice).then(() => alert('Deleted ' + choice)).catch(() => alert('Delete failed')); }
                    }
                };
            } catch (err) { alert('Manage failed: ' + err); }
        });

        // Use as start label update
        // function updateStartLabel(){ startLabel.textContent = `Start: x=${Math.round(fileSettings.startOffsetX||0)}, y=${Math.round(fileSettings.startOffsetY||0)}, zoom=${formatNumber(fileSettings.startZoom||fileSettings.zoom||preview.scale)}`; }

        // ======= Record + Replay workflow (new implementation) =======

        // extra DOM refs
        const btnNext = $('#btnNext'), btnContinue = $('#btnContinue'), overlayReplay = $('#overlayReplay');

        // REPLACE existing recordState declaration with this block
        recordState = Object.assign(recordState, {
            segments: [],         // completed segments: {delay, duration, ydownPercent, startHOffset, endHOffset, speedPxPerSec}
            currentSegment: null, // temp segment while waiting for Continue
            initials: [],         // array of initial positions captured at Record and after each Continue [{hOffset,vOffset,hPct,vPct}]
            startTime: 0,
            firstPanTime: 0,
            firstPanHOffset: 0,
            lastPanHOffset: 0,
            preVOffsetAtNext: 0,
            _timerInterval: null,
            replaying: false,
            pausedReplay: false,
            mode: 'idle'
        });



        // helper to update recTimer text & classes
        function setRecTimerText(text, cls) {
            recTimer.textContent = text;
            recTimer.classList.remove('recording', 'paused', 'replay');
            if (cls) recTimer.classList.add(cls);
        }

        // make preview ignore pointer input during replay
        // Replace previous isReplayActive() with this
        function isReplayActive() {
            // input should be disabled when actively replaying AND not paused.
            // When paused (pausedReplay === true) we allow user panning/interaction.
            return !!recordState.replaying && !recordState.pausedReplay;
        }


        // small safety: if pointer handlers exist elsewhere, honor this flag
        // patch pointer handlers to respect replay lock (insert these checks into your pointer handlers)
        // (see note below where to modify pointerdown/pointermove)

        /* --- recording flow --- */
        // ---------- Record / initial-collection / segment-capture flow ----------
        btnRecord.addEventListener('click', () => {
            if (!currentFile) return alert('Load a file first');

            // helper to show/hide prompt
            const showPrompt = (txt) => { const p = $('#recordPrompt'); if (p) { p.textContent = txt; p.style.display = 'block'; } };
            const hidePrompt = () => { const p = $('#recordPrompt'); if (p) p.style.display = 'none'; };

            // START RECORDING: entering initial-collection mode
            if (recordState.mode === 'idle' || recordState.mode === undefined) {
                // reset recordState for a fresh session
                recordState.mode = 'recording';
                recordState.phase = 'collectInitials';     // two phases: 'collectInitials' | 'captureSegments'
                recordState.initials = [];                 // will hold {hOffset,vOffset,scale,hPct,vPct}
                recordState.segments = [];                 // segments will be filled after capture
                recordState.currentRow = 1;                // 1-based row counter while collecting initials
                recordState.segmentIndex = -1;             // not yet in captureSegments
                recordState.startTime = performance.now(); // used later for delay/duration calculation
                recordState.firstPanTime = 0;
                recordState.firstPanHOffset = 0;
                recordState.lastPanHOffset = 0;
                recordState.currentSegment = null;

                // UI: allow user to position & zoom for the first initial
                preview.lockZoom = false;      // allow zoom BEFORE first Continue
                preview.lockVertical = false;
                overlayRecord.textContent = 'Stop';
                btnNext.hidden = false;
                btnContinue.hidden = false;
                btnContinue.textContent = 'Continue';
                btnNext.textContent = 'Next';

                // show center prompt
                showPrompt(`Please select row ${recordState.currentRow} then click "Continue"`);

                // small timer UX
                setRecTimerText('collect initial', 'recording');

                return;
            }

            // STOP RECORDING: finalize any pending segment/initial then persist & exit
            if (recordState.mode === 'recording') {
                // finalize any pending currentSegment if present (this logic mirrors earlier stop behavior)
                if (recordState.currentSegment) {
                    try {
                        const delta = Math.abs((preview.vOffset || 0) - (recordState.preVOffsetAtNext || 0));
                        const percent = (delta / preview.containerH) * 100;
                        recordState.currentSegment.ydownPercent = Math.round(percent * 100) / 100;
                    } catch (e) {
                        recordState.currentSegment.ydownPercent = 0;
                    }
                    recordState.segments.push(recordState.currentSegment);
                    recordState.currentSegment = null;

                    // capture a following initial for alignment (current preview pos)
                    recordState.initials.push({
                        hOffset: preview.hOffset || 0,
                        vOffset: preview.vOffset || 0,
                        scale: preview.scale || 1,
                        hPct: Math.round(((preview.hOffset || 0) / Math.max(1, preview.containerW)) * 10000) / 100,
                        vPct: Math.round(((preview.vOffset || 0) / Math.max(1, preview.containerH)) * 10000) / 100
                    });
                } else if (recordState.firstPanTime) {
                    // single-row segment case (user panned but never used Next)
                    const now = performance.now();
                    const duration = Math.max(0, now - recordState.firstPanTime) / 1000;
                    const delay = Math.max(0, recordState.firstPanTime - (recordState.startTime || recordState.firstPanTime)) / 1000;
                    const startH = recordState.firstPanHOffset || 0;
                    const endH = recordState.lastPanHOffset || preview.hOffset || startH;
                    const deltaPx = Math.abs(endH - startH);
                    const speedPxPerSec = duration > 0 ? deltaPx / duration : 0;

                    recordState.segments.push({
                        delay: Math.round(delay * 100) / 100,
                        duration: Math.round(duration * 100) / 100,
                        ydownPercent: 0,
                        startHOffset: startH,
                        endHOffset: endH,
                        speedPxPerSec: Math.round(speedPxPerSec * 100) / 100
                    });

                    // capture current preview as next initial
                    recordState.initials.push({
                        hOffset: preview.hOffset || 0,
                        vOffset: preview.vOffset || 0,
                        scale: preview.scale || 1,
                        hPct: Math.round(((preview.hOffset || 0) / Math.max(1, preview.containerW)) * 10000) / 100,
                        vPct: Math.round(((preview.vOffset || 0) / Math.max(1, preview.containerH)) * 10000) / 100
                    });
                }

                recordState.mode = 'idle';
                recordState.phase = 'idle';
                preview.lockZoom = false;
                preview.lockVertical = false;
                overlayRecord.textContent = 'Record';
                btnNext.hidden = true;
                btnContinue.hidden = true;

                // stop the rec timer RAF loop and reset UI badge
                stopRecTimer();
                setRecTimerText('0.0s', 'paused');


                // persist both segments and initials to fileSettings & DB
                try {
                    fileSettings.segments = recordState.segments.slice();
                    fileSettings.initials = recordState.initials.slice();
                } catch (e) { /* ignore */ }
                if (typeof saveRecord === 'function') saveRecord();

                overlayReplay.hidden = !(fileSettings.segments && fileSettings.segments.length);

                // hide prompt
                hidePrompt();
                return;
            }
        });



        // REPLACE existing btnNext click handler with this block
        btnNext.addEventListener('click', () => {
            if (recordState.mode !== 'recording') return;

            // If we are still collecting initials, Next means "stop collecting and start capturing segments"
            if (recordState.phase === 'collectInitials') {
                // if user never pressed Continue for any initial yet -> capture current as initial[0]
                if (!recordState.initials.length) {
                    recordState.initials.push({
                        hOffset: preview.hOffset || 0,
                        vOffset: preview.vOffset || 0,
                        scale: preview.scale || 1,
                        hPct: Math.round(((preview.hOffset || 0) / Math.max(1, preview.containerW)) * 10000) / 100,
                        vPct: Math.round(((preview.vOffset || 0) / Math.max(1, preview.containerH)) * 10000) / 100
                    });
                    // lock zoom after first captured initial
                    preview.lockZoom = true;

                }

                // switch to captureSegments phase
                recordState.phase = 'captureSegments';
                recordState.segmentIndex = 0;
                recordState.startTime = performance.now();
                recordState.firstPanTime = 0;
                recordState.firstPanHOffset = 0;
                recordState.lastPanHOffset = 0;


                recordState.startTime = performance.now();
                preview.lockVertical = true;
                startRecTimer();               // begin/reset rec timer measuring delay for this row


                // UI: hide continue (no longer used) and keep Next visible for segment finalization
                btnContinue.hidden = true;
                btnNext.hidden = false;
                setRecTimerText('0.0s', 'recording');

                // move preview to initial of row 1
                applyInitial(0);

                // keep vertical pan enabled and keep the prompt invisible for the new row                
                const p = $('#recordPrompt'); if (p) p.style.display = 'none';

                // // update prompt to show we are now capturing segments
                // const p = $('#recordPrompt'); if (p) p.textContent = `Capturing segment for row 1 — pan to record, then click "Next"`;
                return;
            }

            // If we are in captureSegments: Next means finalize the current segment and move to next initial
            if (recordState.phase === 'captureSegments') {
                // ensure some panning happened (firstPanTime may be set by pointermove)
                if (!recordState.firstPanTime) {
                    // no pan detected yet; treat duration as 0 and set start/end to current h
                    // but we still progress to next row to avoid blocking
                }
                const now = performance.now();
                const duration = recordState.firstPanTime ? Math.max(0, now - recordState.firstPanTime) / 1000 : 0;
                const delay = recordState.firstPanTime ? Math.max(0, recordState.firstPanTime - (recordState.startTime || recordState.firstPanTime)) / 1000 : 0;
                const startH = recordState.firstPanHOffset || 0;
                const endH = recordState.lastPanHOffset || preview.hOffset || startH;
                const deltaPx = Math.abs(endH - startH);
                const speedPxPerSec = duration > 0 ? deltaPx / duration : 0;

                // create segment and push
                const seg = {
                    delay: Math.round(delay * 100) / 100,
                    duration: Math.round(duration * 100) / 100,
                    ydownPercent: 0, // will be computed when user adjusts vertical for next initial (if needed)
                    startHOffset: startH,
                    endHOffset: endH,
                    speedPxPerSec: Math.round(speedPxPerSec * 100) / 100
                };
                recordState.segments.push(seg);

                // compute ydown now using preVOffsetAtNext if any (the code path that previously used preVOffsetAtNext)
                try {
                    const delta = Math.abs((preview.vOffset || 0) - (recordState.preVOffsetAtNext || 0));
                    seg.ydownPercent = Math.round(((delta / preview.containerH) * 100) * 100) / 100;
                } catch (e) { seg.ydownPercent = 0; }

                // persist segment immediately
                try { fileSettings.segments = recordState.segments.slice(); } catch (e) { }
                if (typeof saveRecord === 'function') saveRecord();

                // move to next initial (if any)
                recordState.segmentIndex = (recordState.segmentIndex || 0) + 1;
                const nextIdx = recordState.segmentIndex;
                const nextInit = recordState.initials[nextIdx];

                if (nextInit) {
                    // move preview to next initial position + scale
                    preview.scale = (typeof nextInit.scale !== 'undefined') ? nextInit.scale : preview.scale;
                    preview.hOffset = nextInit.hOffset || 0;
                    preview.vOffset = nextInit.vOffset || 0;
                    updatePreviewTransform();

                    // reset timers for next row
                    recordState.startTime = performance.now();
                    recordState.firstPanTime = 0;
                    recordState.firstPanHOffset = 0;
                    recordState.lastPanHOffset = 0;
                    recordState.preVOffsetAtNext = preview.vOffset || 0;

                    // ensure rec timer restarts and vertical pan stays locked for the next capture
                    startRecTimer();
                    preview.lockVertical = true;

                    // update prompt
                    const p = $('#recordPrompt'); if (p) p.textContent = `Capturing segment for row ${nextIdx + 1} — pan to record, then click "Next"`;
                    setRecTimerText('0.0s', 'recording');
                    return;

                } else {
                    // no more initials — finish recording
                    recordState.mode = 'idle';
                    recordState.phase = 'idle';
                    preview.lockZoom = false;
                    preview.lockVertical = false;
                    overlayRecord.textContent = 'Record';
                    btnNext.hidden = true;
                    btnContinue.hidden = true;
                    setRecTimerText('0.0s', 'paused');

                    // persist final data
                    try { fileSettings.segments = recordState.segments.slice(); fileSettings.initials = recordState.initials.slice(); } catch (e) { }
                    if (typeof saveRecord === 'function') saveRecord();

                    const p = $('#recordPrompt'); if (p) { p.style.display = 'none'; }
                    overlayReplay.hidden = !(fileSettings.segments && fileSettings.segments.length);

                    alert('Recording finished.');
                    return;
                }
            }
        });



        // Continue pressed: capture vertical difference (ydown) and prepare next cycle
        btnContinue.addEventListener('click', async () => {
            // Only meaningful during initial-collection phase
            if (recordState.mode !== 'recording') return;

            // --- fade to black for recording-continue (100ms) ---
            let fadeCover = document.getElementById('replayFadeCover');
            if (!fadeCover) {
                fadeCover = document.createElement('div');
                fadeCover.id = 'replayFadeCover';
                fadeCover.style.position = 'fixed';
                fadeCover.style.left = '0';
                fadeCover.style.top = '0';
                fadeCover.style.width = '100%';
                fadeCover.style.height = '100%';
                fadeCover.style.background = '#000';
                fadeCover.style.pointerEvents = 'none';
                fadeCover.style.zIndex = 999998;
                fadeCover.style.opacity = '0';
                fadeCover.style.transition = 'opacity 100ms linear';
                document.body.appendChild(fadeCover);
            }
            try { fadeCover.style.opacity = '1'; } catch (e) { /* ignore */ }
            await new Promise(r => setTimeout(r, 120)); // wait ~100ms fade
            // --- end fade-in ---

            // restore after 200ms (short delay so next prompt is readable)
            setTimeout(() => {
                try { fadeCover.style.opacity = '0'; } catch (e) { /* ignore */ }
            }, 100);

            if (recordState.phase === 'collectInitials') {
                // capture the current preview position as an initial for currentRow
                const h = preview.hOffset || 0, v = preview.vOffset || 0, sc = preview.scale || 1;
                recordState.initials.push({
                    hOffset: h,
                    vOffset: v,
                    scale: sc,
                    hPct: Math.round((h / Math.max(1, preview.containerW)) * 10000) / 100,
                    vPct: Math.round((v / Math.max(1, preview.containerH)) * 10000) / 100
                });

                // After first continue, lock zoom permanently for the session
                if (recordState.initials.length === 1) {
                    preview.lockZoom = true;
                }

                // persist progress
                try { fileSettings.initials = recordState.initials.slice(); } catch (e) { }
                if (typeof saveRecord === 'function') saveRecord();

                // increment row counter and update prompt
                recordState.currentRow = (recordState.currentRow || 1) + 1;
                const p = $('#recordPrompt');
                if (p) p.textContent = `Please select row ${recordState.currentRow} then click "Continue"`;

                // reset any timers related to segment capture (we are still collecting initials)
                setRecTimerText('collect initial', 'recording');
                return;
            }

            // If in captureSegments phase: Continue is not used (ignore)


        });



        // Helper: record first and last pan positions on pointermove (we will use these for delay/duration & speed)
        (function patchPointerHandlersForRecording() {
            // insert a guard into existing pointer handlers: if replay active -> ignore pointer events
            // Modify the beginning of your previewCanvas pointerdown handler to do:
            // if(isReplayActive()) return;
            // And modify pointermove similarly.
            // Below we only wire the recording-specific capture (non-destructive to your existing handler).
            previewCanvas.addEventListener('recording_internal_pointermove', () => { }); // noop marker

            // We rely on the existing pointermove which already updates preview.hOffset / vOffset.
            // So we only add a small listener to capture the recording timestamps.
            previewCanvas.addEventListener('pointermove', (e) => {
                // if replay is active, ignore user input here (do not change recorded timestamps)
                if (isReplayActive()) return;

                // only capture when actual dragging
                if (!activePointers.has(e.pointerId)) return;
                if (activePointers.size === 1 && preview.dragging) {
                    // detect first pan for a new recording segment
                    if (recordState.mode === 'recording' && recordState.phase === 'captureSegments' && !recordState.firstPanTime) {
                        recordState.firstPanTime = performance.now();
                        recordState.firstPanHOffset = preview.hOffset;
                    }

                    if (recordState.mode === 'recording') {
                        // always update lastPanHOffset to calculate speed if needed (end position)
                        recordState.lastPanHOffset = preview.hOffset;
                    }
                }
            });
        })();

        /* --- replay flow --- */

        // small helper to sleep while allowing pause/resume
        function sleepMs(ms) {
            return new Promise(resolve => {
                const start = performance.now();
                (function tick() {
                    if (recordState.pausedReplay) {
                        // poll until unpaused
                        setTimeout(tick, 120);
                        return;
                    }
                    const now = performance.now();
                    if (now - start >= ms) return resolve();
                    setTimeout(tick, 50);
                })();
            });
        }

        // --- REPLACE existing animateProperty with this block ---
        function easeInOutCubic(t) {
            // smooth ease-in-out cubic
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // --- REPLACE existing animateProperty with this block ---
        function animateProperty(durationMs, onProgress) {
            return new Promise(resolve => {
                if (!recordState.replayController) recordState.replayController = { skipSegment: false, aborted: false };

                // how long (ms) to apply easing at start and end
                const edgeEaseMs = 1000; // 1 second start + 1 second end

                // curve power for easing (cubic gives smooth accel/decel)
                const m = 3;

                // defensive immediate-complete
                if (durationMs <= 0) {
                    try { onProgress(1); } catch (e) { /* ignore */ }
                    recordState.currentSegmentProgress = 1;
                    return resolve('done');
                }

                // fraction of whole duration spent easing at each edge
                let alpha = edgeEaseMs / durationMs;
                // clamp alpha to sensible range (prevent numerical issues if edgeEaseMs > durationMs)
                if (alpha >= 0.49) alpha = 0.49;

                // for very short durations: fallback to symmetric ease-in-out
                const useFullEaseFallback = (durationMs <= 2 * edgeEaseMs);

                // Precompute S (total fraction of position consumed by one easing edge)
                // Derived so that derivative at the end of easing equals the constant middle speed.
                // S = alpha / ( m*(1 - 2*alpha) + 2*alpha )
                const S = useFullEaseFallback ? null : (alpha / (m * (1 - 2 * alpha) + 2 * alpha));
                const Lm = 1 - 2 * alpha; // middle fraction length
                const k = useFullEaseFallback ? null : (m * S / alpha); // middle slope (derivative) = constant speed

                let elapsed = 0;
                let lastTick = performance.now();

                function step() {
                    // abort
                    if (!recordState.replaying || (recordState.replayController && recordState.replayController.aborted)) {
                        try { onProgress(1); } catch (e) { /* ignore */ }
                        recordState.currentSegmentProgress = 1;
                        return resolve('aborted');
                    }

                    // skip
                    if (recordState.replayController && recordState.replayController.skipSegment) {
                        try { onProgress(1); } catch (e) { /* ignore */ }
                        recordState.replayController.skipSegment = false;
                        recordState.currentSegmentProgress = 1;
                        return resolve('skipped');
                    }

                    const now = performance.now();
                    if (!recordState.pausedReplay) elapsed += (now - lastTick);
                    lastTick = now;

                    const pRaw = Math.min(1, elapsed / durationMs); // linear time progress 0..1

                    if (useFullEaseFallback) {
                        // Short total duration: symmetric ease-in-out across whole motion (smooth but no constant middle)
                        // Use cubic ease-in/out across full 0..1
                        const half = 0.5;
                        let eased;
                        if (pRaw < half) {
                            eased = 0.5 * Math.pow(pRaw / half, m);
                        } else {
                            eased = 0.5 + 0.5 * (1 - Math.pow((1 - pRaw) / half, m));
                        }
                        try { onProgress(eased); } catch (e) { /* ignore */ }
                        recordState.currentSegmentProgress = pRaw;
                        if (pRaw >= 1) return resolve('done');
                        return requestAnimationFrame(step);
                    }

                    // Normal case: piecewise function that creates:
                    // start ease (0..alpha) -> middle linear (alpha..1-alpha) -> end ease (1-alpha..1)
                    let easedP;
                    if (pRaw <= alpha) {
                        // start easing: easedP = S * (pRaw/alpha)^m
                        const local = pRaw / alpha;
                        easedP = S * Math.pow(local, m);
                    } else if (pRaw >= 1 - alpha) {
                        // end easing: easedP = 1 - S * ((1 - pRaw)/alpha)^m
                        const local = (1 - pRaw) / alpha;
                        easedP = 1 - S * Math.pow(local, m);
                    } else {
                        // middle constant-speed segment: linear from S to 1 - S with slope k
                        easedP = S + k * (pRaw - alpha);
                    }

                    try { onProgress(easedP); } catch (e) { /* ignore */ }
                    recordState.currentSegmentProgress = pRaw;

                    if (pRaw >= 1) return resolve('done');
                    requestAnimationFrame(step);
                }

                requestAnimationFrame(step);
            });
        }





        // ---------- Front-layer helpers ----------
        function applyFrontInitial(nextInit) {
            if (!nextInit) {
                previewImgFront.style.display = 'none';
                return;
            }
            previewImgFront.style.display = 'block';
            // position/scale to match the saved initial (use preview.rotation for consistency)
            const sc = (typeof nextInit.scale !== 'undefined') ? nextInit.scale : (preview.scale || 1);
            const hx = typeof nextInit.hOffset !== 'undefined' ? nextInit.hOffset : 0;
            const vy = typeof nextInit.vOffset !== 'undefined' ? nextInit.vOffset : 0;
            previewImgFront.style.transform = `translate3d(${-Math.round(hx)}px, ${-Math.round(vy)}px, 0) rotate(${preview.rotation}deg) scale(${sc})`;
            // start fully hidden (clip-path: reveal from left by changing right inset)
            previewImgFront.style.clipPath = 'inset(0 100% 0 0)';
            previewImgFront.style.transition = '';
        }
        function showFrontFullyImmediate() {
            if (!previewImgFront || previewImgFront.style.display === 'none') return;
            previewImgFront.style.transition = 'clip-path 220ms ease';
            previewImgFront.style.clipPath = 'inset(0 0 0 0)';
            // after transition clear inline transition (caller may await ~230ms)
            setTimeout(() => { previewImgFront.style.transition = ''; }, 260);
        }
        function hideFront() {
            if (!previewImgFront) return;
            previewImgFront.style.display = 'none';
            previewImgFront.style.clipPath = 'inset(0 100% 0 0)';
        }

        function elementhide(element) {
            element.hidden = true;
            element.setAttribute('aria-hidden', 'true');
        }

        function elementshow(element) {
            element.hidden = false;
            element.removeAttribute('aria-hidden');
        }

        function hideui() {
            const zoomlabel = $('#zoomlabel');
            const btnPause = $('#overlayPause');

            elementhide(overlayRecord);
            elementhide(zoomSlider);
            elementhide(zoomlabel);
            elementhide(overlayLoad);
            // elementhide(btnPause);    
            // elementhide(fileLabel);     

        }

        function showui() {
            const zoomlabel = $('#zoomlabel');
            const btnPause = $('#overlayPause');

            elementshow(overlayRecord);
            elementshow(zoomSlider);
            elementshow(zoomlabel);
            elementshow(overlayLoad);
            // elementshow(btnPause);    
            // elementshow(fileLabel);                         
        }

        async function startReplay() {
            fileSettings.playbackspeed = fileSettings.playbackspeed || 100;
            fileSettings.autoplayback = !!fileSettings.autoplayback;

            if (!fileSettings.segments || !fileSettings.segments.length) return alert('No recorded segments to replay.');



            // prepare UI + lock inputs
            recordState.replaying = true;
            recordState.pausedReplay = false;
            overlayReplay.textContent = 'Stop';
            overlayRecord.disabled = true;
            preview.lockZoom = true;
            preview.lockVertical = true;


            // --- show / initialize static playback controls (no dynamic creation) ---
            const btnPause = document.getElementById('overlayPause');
            if (btnPause) btnPause.hidden = false;

            const pbRew = document.getElementById('overlayPBRew');
            const pbFwd = document.getElementById('overlayPBFwd');
            const pbAuto = document.getElementById('overlayPBAuto');

            if (pbRew) pbRew.hidden = false;
            if (pbFwd) pbFwd.hidden = false;
            if (pbAuto) pbAuto.style.display = 'inline-flex';

            // wire the checkbox ONCE (avoid duplicate listeners)
            const chk = document.getElementById('overlayAutoChk');
            if (chk) {
                chk.checked = !!fileSettings.autoplayback;
                if (!chk._wired) {
                    chk.addEventListener('change', (e) => {
                        fileSettings.autoplayback = !!e.target.checked;
                        if (typeof saveRecord === 'function') saveRecord();
                        const fl = document.getElementById('fileLabel');
                        if (fl) {
                            const prev = fl.textContent;
                            fl.style.color = 'red';
                            fl.textContent = fileSettings.autoplayback ? 'Auto ON' : 'Auto OFF';
                            setTimeout(() => { fl.style.color = ''; fl.textContent = prev; }, 2000);
                        }
                    });
                    chk._wired = true;
                }
            }



            hideui();

            // Flash helper that resets the timeout on repeated clicks.
            // Shows `text` immediately and reverts to the real filename only ms after last call.
            let __fileLabelFlashTimeout = null;

            function flashPlaybackLabel(text, ms = 3000) {
                const fl = document.getElementById('fileLabel');
                if (!fl) return;

                // store original filename if not stored yet (do this once when a file is loaded)
                if (!fl.dataset.orig) {
                    // if you have currentFile set elsewhere, prefer that name:
                    if (typeof currentFile !== 'undefined' && currentFile && currentFile.name) {
                        fl.dataset.orig = currentFile.name;
                    } else {
                        fl.dataset.orig = fl.textContent || '';
                    }
                }

                // show temporary text
                fl.style.color = 'red';
                fl.textContent = text;

                // reset existing timer so repeated clicks keep the temporary text visible
                if (__fileLabelFlashTimeout) {
                    clearTimeout(__fileLabelFlashTimeout);
                }

                __fileLabelFlashTimeout = setTimeout(() => {
                    __fileLabelFlashTimeout = null;
                    fl.style.color = '';
                    // Always restore to the loaded filename (if available) or the original stored value
                    fl.textContent = fl.dataset.orig || '';
                }, ms);
            }


            // show current numeric playback speed for 3s when user presses replay
            flashPlaybackLabel(String(fileSettings.playbackspeed || 100) + '%', 3000);


            // --- playback step configuration (adjust step/min/max as you like) ---
            const PLAYBACK_STEP = 2;     // each click changes by 2%
            const PLAYBACK_MIN = 20;     // lower bound
            const PLAYBACK_MAX = 500;    // upper bound

            // Fast forward: INCREASE percent (bigger number = faster)
            pbFwd.addEventListener('click', () => {
                fileSettings.playbackspeed = Math.min(PLAYBACK_MAX, (fileSettings.playbackspeed || 100) + PLAYBACK_STEP);
                if (typeof saveRecord === 'function') saveRecord();
                flashPlaybackLabel(String(fileSettings.playbackspeed) + '%');
            });

            // Rewind / slow down: DECREASE percent (smaller number = slower)
            pbRew.addEventListener('click', () => {
                fileSettings.playbackspeed = Math.max(PLAYBACK_MIN, (fileSettings.playbackspeed || 100) - PLAYBACK_STEP);
                if (typeof saveRecord === 'function') saveRecord();
                flashPlaybackLabel(String(fileSettings.playbackspeed) + '%');
            });

            // auto checkbox wiring
            // const chk = document.getElementById('overlayAutoChk');
            if (chk) {
                // initialize from fileSettings
                chk.checked = !!fileSettings.autoplayback;

            }



            // ensure replay controller
            recordState.replayController = { skipSegment: false, aborted: false };
            recordState.replayRecalcOnResume = false;

            // show timer style to replay (blue)
            setRecTimerText('0.0s', 'replay');

            const segments = fileSettings.segments.slice();
            const initials = (fileSettings.initials || []).slice();

            // create blink indicator element (2px vertical line at right)
            let blinkEl = document.getElementById('replayBlinkLine');
            if (!blinkEl) {
                blinkEl = document.createElement('div');
                blinkEl.id = 'replayBlinkLine';
                blinkEl.style.position = 'fixed';
                blinkEl.style.top = '0';
                blinkEl.style.right = '0';
                blinkEl.style.width = '2px';
                blinkEl.style.height = '100%';
                blinkEl.style.zIndex = 999999;
                blinkEl.style.pointerEvents = 'auto';
                blinkEl.style.display = 'none';
                document.body.appendChild(blinkEl);
            }

            // create fade cover for natural transition
            let fadeCover = document.getElementById('replayFadeCover');
            if (!fadeCover) {
                fadeCover = document.createElement('div');
                fadeCover.id = 'replayFadeCover';
                fadeCover.style.position = 'fixed';
                fadeCover.style.left = '0';
                fadeCover.style.top = '0';
                fadeCover.style.width = '100%';
                fadeCover.style.height = '100%';
                fadeCover.style.background = '#000';
                fadeCover.style.pointerEvents = 'none';
                fadeCover.style.zIndex = 999998;
                fadeCover.style.opacity = '0';
                fadeCover.style.transition = 'opacity 100ms linear';
                document.body.appendChild(fadeCover);
            }

            // helper: find index of initial closest to current preview.vOffset
            function findClosestInitialIndex() {
                if (!initials || !initials.length) return 0;
                let best = 0, bestDist = Infinity, curV = preview.vOffset || 0;
                for (let k = 0; k < initials.length; k++) {
                    const d = Math.abs((initials[k].vOffset || 0) - curV);
                    if (d < bestDist) { best = k; bestDist = d; }
                }
                return best;
            }

            // helper: show/hide blinking line with fast blinking animation
            let blinkHandler = null;
            function showBlink() {
                blinkEl.style.display = 'block';
                blinkEl.style.background = '#000';
                blinkEl.style.animation = 'replayBlink 240ms steps(2,start) infinite';
                // add click/tap handler to let user skip to next row or to resume "waiting" state
                blinkHandler = (ev) => {
                    ev.stopPropagation(); ev.preventDefault();
                    if (!recordState.replayController) recordState.replayController = {};
                    recordState.replayController.skipSegment = true;

                    // Mark that a programmatic "continue" was requested so any future manual wait will auto-resolve.
                    // Also call the resolver now if it already exists.
                    if (!recordState.replayController) recordState.replayController = {};
                    recordState.replayController.autoContinueRequested = true;

                    if (typeof recordState._resolveManualContinue === 'function') {
                        try { recordState._resolveManualContinue(); } catch (e) { /* ignore */ }
                        recordState._resolveManualContinue = null;
                        // we handled it immediately — clear the request flag
                        recordState.replayController.autoContinueRequested = false;
                    }


                    hideBlink();
                };
                blinkEl.addEventListener('pointerdown', blinkHandler);
            }

            function hideBlink() {
                blinkEl.style.display = 'none';
                blinkEl.style.animation = '';
                if (blinkHandler) { blinkEl.removeEventListener('pointerdown', blinkHandler); blinkHandler = null; }
            }

            // keyframes for blink (inject style if not present)
            if (!document.getElementById('replayBlinkStyle')) {
                const s = document.createElement('style');
                s.id = 'replayBlinkStyle';
                s.textContent = `
      @keyframes replayBlink { 0% { opacity:1 } 50% { opacity:0 } 100% { opacity:1 } }
    `;
                document.head.appendChild(s);
            }

            // main loop
            for (let i = 0; i < segments.length; i++) {
                // if we need to recalc which index to play next (occurs after Resume)
                if (recordState.replayRecalcOnResume) {
                    const newIdx = findClosestInitialIndex();
                    // set loop index to newIdx
                    i = Math.max(0, newIdx);
                    recordState.replayRecalcOnResume = false;
                }

                const seg = segments[i];
                const init = (initials && initials[i]) ? initials[i] : null;

                // restore baseline from saved initials if available (preferred)
                if (init) {
                    preview.scale = (typeof init.scale !== 'undefined') ? init.scale : (preview.scale || 1);
                    preview.hOffset = (typeof init.hOffset !== 'undefined') ? init.hOffset : (seg.startHOffset || 0);
                    preview.vOffset = (typeof init.vOffset !== 'undefined') ? init.vOffset : (preview.vOffset || 0);
                } else {
                    preview.hOffset = seg.startHOffset || 0;
                }
                updatePreviewTransform();
                // prepare front-layer preview for the next row (duplicate of image, positioned at next initial)
                const nextInit = (initials && initials[i + 1]) ? initials[i + 1] : null;
                applyFrontInitial(nextInit);

                // if paused by user earlier, wait until resumed (this ensures resume recalc happens)
                while (recordState.pausedReplay && recordState.replaying) {
                    await new Promise(r => setTimeout(r, 100));
                }
                if (!recordState.replaying) break;

                // DELAY: if current preview.hOffset is already past startHOffset:
                // - if h <= startH: play delay normally
                // - if h between start and end: skip delay and compute remaining duration

                // apply playback speed factor from fileSettings (percent). 100 => normal (factor 1).
                // We want larger percent → faster playback, so invert the mapping: 200% => 0.5 (half duration).
                const playbackFactor = 100 / (fileSettings.playbackspeed || 100);

                const delayMs = Math.max(0, (seg.delay || 0)) * 1000 * playbackFactor;
                const startH = (typeof seg.startHOffset !== 'undefined') ? seg.startHOffset : (preview.hOffset || 0);
                const endH = (typeof seg.endHOffset !== 'undefined') ? seg.endHOffset : startH;
                const curH = preview.hOffset || 0;

                // compute whether to play full delay
                if (curH <= startH) {
                    // play delay with timer

                    if (delayMs > 0) {
                        const start = performance.now();
                        let pausedAt = 0;
                        let pauseAccum = 0;

                        while (performance.now() - start - pauseAccum < delayMs) {
                            if (!recordState.replaying) break;

                            if (recordState.replayController && (recordState.replayController.skipSegment || recordState.replayController.aborted)) {
                                break;
                            }
                            if (recordState.replayRecalcOnResume) {
                                break;
                            }

                            if (recordState.pausedReplay) {
                                // start pause timestamp if not already paused
                                if (!pausedAt) pausedAt = performance.now();
                                // poll while paused
                                await new Promise(r => setTimeout(r, 100));
                                continue;
                            } else {
                                // if we were paused, accumulate the paused duration
                                if (pausedAt) {
                                    pauseAccum += (performance.now() - pausedAt);
                                    pausedAt = 0;
                                }
                            }

                            // show delay timer based on active (non-paused) elapsed
                            const activeElapsed = (performance.now() - start - pauseAccum);
                            setRecTimerText((activeElapsed / 1000).toFixed(1) + 's', 'replay');

                            await new Promise(r => setTimeout(r, 80));
                        }
                    }



                    if (!recordState.replaying) break;
                }
                // If curH > startH and curH < endH we will compute remaining duration below and animate only the remaining portion.
                if (!recordState.replaying) break;

                // Determine duration remaining and start point for animation
                const fullDurMs = Math.max(0, (seg.duration || 0)) * 1000 * playbackFactor;
                let animFrom = curH;
                let animTo = endH;
                let animDurMs = fullDurMs;

                if (curH > startH && curH < endH && endH !== startH) {
                    // user is already mid-way: compute fraction completed and remaining duration
                    const fracCompleted = (curH - startH) / (endH - startH);
                    animDurMs = Math.max(0, fullDurMs * (1 - fracCompleted));
                    // animFrom is current curH already set
                } else if (curH >= endH) {
                    // already past end; skip animation
                    animDurMs = 0;
                    animFrom = endH;
                    animTo = endH;
                } else {
                    // normal case: start from startH to endH with full duration
                    animFrom = curH <= startH ? startH : curH;
                    animTo = endH;
                    // if animFrom != startH and curH < startH, we should start from startH
                    if (animFrom === startH) {
                        animDurMs = fullDurMs;
                    }
                }

                // Now animate horizontal pan. We will monitor remaining time for blinking 2s before end.
                let blinkShown = false;
                // reset skip flag
                if (recordState.replayController) recordState.replayController.skipSegment = false;

                if (animDurMs > 0) {


                    // animateProperty will call onProgress from 0..1 over animDurMs
                    const result = await animateProperty(animDurMs, (p) => {
                        // compute current hOffset
                        preview.hOffset = animFrom + (animTo - animFrom) * p;
                        updatePreviewTransform();

                        // --- front reveal while panning: reveal front from left gradually up to 50% and then lock ---
                        try {
                            if (nextInit && previewImgFront && previewImgFront.style.display !== 'none') {
                                // compute scaled image width and total horizontal travel D_x
                                const rot = ((preview.rotation % 360) + 360) % 360;
                                const is90 = (rot === 90 || rot === 270);
                                const scaledW = (is90 ? preview.imgH : preview.imgW) * preview.scale;
                                const D_x = Math.max(0, scaledW - preview.containerW);

                                // tune: how many px before the end to start revealing
                                const revealStartPx = Math.min(preview.containerW * 0.6, 400);
                                const triggerStart = Math.max(0, D_x - revealStartPx);

                                // ensure transitions are off while we're changing clip-path progressively
                                previewImgFront.style.transition = '';

                                // reveal fraction 0..50 while preview.hOffset moves from triggerStart -> D_x
                                let revealPct = 0;
                                if (preview.hOffset > triggerStart) {
                                    revealPct = ((preview.hOffset - triggerStart) / Math.max(1, revealStartPx)) * (preview.containerW / scaledW) * 50; // 0..50
                                    if (revealPct < 0) revealPct = 0;
                                    if (revealPct >= 49 * (preview.containerW / scaledW)) {
                                        revealPct = 50;
                                        //console.log('');
                                    }
                                }

                                // If already locked at half, keep it exactly 50
                                if (frontAwaitingTap) {
                                    revealPct = 50 * (preview.containerW / scaledW);
                                } else if (revealPct >= 49 * (preview.containerW / scaledW)) {
                                    // first time we reach 50% -> lock and show hint
                                    revealPct = 49 * (containerW / scaledW);
                                    frontAwaitingTap = true;

                                    console.log('front locked at 50% at hOffset=', preview.hOffset, 'D_x=', D_x);

                                    if (typeof hintEl !== 'undefined' && hintEl) {
                                        hintEl.hidden = false; // show hint
                                    }
                                    // write the locked 50% explicitly (no transition)
                                    const clip50 = 'inset(0 50% 0 0)';
                                    if (previewImgFront.style.clipPath !== clip50) {
                                        previewImgFront.style.clipPath = clip50;
                                    }
                                    return; // done for this tick
                                }

                                // apply clip-path only when it actually changes (avoids extra writes)
                                const newClip = `inset(0 ${100 - revealPct}% 0 0)`;
                                if (previewImgFront.style.clipPath !== newClip) {
                                    previewImgFront.style.clipPath = newClip;
                                }

                                // --- show a 2px blue vertical line at the reveal border and keep it in sync ---
                                // create the line once (attached to previewCanvas)
                                let revealLine = document.getElementById('previewRevealLine');
                                if (!revealLine) {
                                    revealLine = document.createElement('div');
                                    revealLine.id = 'previewRevealLine';
                                    revealLine.style.position = 'absolute';
                                    revealLine.style.top = '0';
                                    revealLine.style.height = '100%';
                                    revealLine.style.width = '2px';
                                    revealLine.style.background = '#1e90ff'; // blue (change if you prefer another blue)
                                    revealLine.style.zIndex = '3';           // above previewImgFront (which uses zIndex = 2)
                                    revealLine.style.pointerEvents = 'none'; // don't block input
                                    revealLine.style.display = 'none';
                                    previewCanvas.appendChild(revealLine);
                                }

                                // only show the line when there's a visible reveal amount
                                if (typeof revealPct === 'number' && revealPct > 0) {
                                    // nextInit was set earlier per-row; use its saved hOffset as the front-image baseline
                                    const hx = (nextInit && typeof nextInit.hOffset !== 'undefined') ? nextInit.hOffset : 0;

                                    // scaledW computed above in this scope: use same value (if not available, compute)
                                    // (defensive fallback)
                                    const rot = ((preview.rotation % 360) + 360) % 360;
                                    const is90 = (rot === 90 || rot === 270);
                                    const scaledW_local = (typeof scaledW !== 'undefined') ? scaledW : ((is90 ? preview.imgH : preview.imgW) * preview.scale);

                                    // compute reveal pixel inside the front-image and map to container coords:
                                    const revealPxInImage = scaledW_local * (revealPct / 100);
                                    // front image is translated by -hx so image x=0 sits at container x = -hx
                                    let borderX = Math.round(revealPxInImage - hx);

                                    // clamp to preview container bounds
                                    borderX = Math.max(0, Math.min(preview.containerW, borderX));

                                    revealLine.style.left = borderX + 'px';
                                    revealLine.style.display = 'block';
                                } else {
                                    // hide when not revealing
                                    if (document.getElementById('previewRevealLine')) {
                                        document.getElementById('previewRevealLine').style.display = 'none';
                                    }
                                }

                            }
                        } catch (e) { /* defensive */ }



                        // update timer to show duration progression
                        setRecTimerText((p * (seg.duration || 0)).toFixed(1) + 's', 'replay');

                        // blinking logic: if remaining time <= 2000ms and blink not yet shown, show it
                        const elapsed = p * animDurMs;
                        const remaining = animDurMs - elapsed;
                        if (remaining <= 2000 && !blinkShown) {
                            blinkShown = true;
                            showBlink();
                        }
                    });

                    // if animateProperty was skipped (user tapped blink or resume triggered skip), result === 'skipped'
                    if (result === 'skipped') {
                        // user forced skip (via blink click or resume). Instead of forcing preview.hOffset
                        // to the next initial/end immediately, continue this same segment from the
                        // current visible preview.hOffset to animTo over the *remaining* time.
                        hideBlink();

                        // compute full distance originally intended and remaining fraction
                        const fullDist = animTo - animFrom;
                        const doneDist = preview.hOffset - animFrom;
                        let fracDone = 0;
                        if (Math.abs(fullDist) > 0.0001) {
                            fracDone = doneDist / fullDist;
                            // clamp
                            if (fracDone < 0) fracDone = 0;
                            if (fracDone > 1) fracDone = 1;
                        } else {
                            fracDone = 1;
                        }

                        // remaining time proportional to remaining distance
                        let remainingMs = Math.max(0, animDurMs * (1 - fracDone));

                        // If user has panned past the end or nearly at the end, snap to animTo immediately
                        if (Math.abs(animTo - preview.hOffset) < 0.5 || remainingMs <= 16) {
                            preview.hOffset = animTo;
                            updatePreviewTransform();
                        } else {
                            // show blink if the remaining time is short (keep previous UX)
                            if (remainingMs <= 2000) {
                                showBlink();
                            }

                            // Animate from the current visible position to animTo in remainingMs
                            const resumeStart = preview.hOffset;
                            // animateProperty will respect recordState.pausedReplay/skip flags
                            await animateProperty(remainingMs, (p) => {
                                // p is 0..1 across the remaining time
                                preview.hOffset = resumeStart + (animTo - resumeStart) * p;
                                updatePreviewTransform();

                                // update timer to reflect overall progress in this segment
                                // overallProgress = fracDone + p * (1 - fracDone)
                                const overallProgress = Math.min(1, Math.max(0, fracDone + p * (1 - fracDone)));
                                setRecTimerText((overallProgress * (seg.duration || 0)).toFixed(1) + 's', 'replay');

                                // blinking: if near the very end, ensure blink shown (defensive; showBlink already above if remaining <= 2s)
                                const elapsed = overallProgress * animDurMs;
                                const remaining = animDurMs - elapsed;
                                // keep blink visible while waiting near end
                                if (remaining <= 2000) {
                                    try { showBlink(); } catch (e) { }
                                }
                            });
                        }

                        // After finishing anim (or snapping) we simply fall through to the normal
                        // post-animation code below (vertical target/fade etc).  Do NOT force a
                        // jump to the next initial here — keep the natural flow so vertical switch
                        // and pause/wait happen in the same place as for a normal completion.
                    }

                } else {
                    // immediate set — but smoothly "snap" if the distance is noticeable
                    const cur = (preview.hOffset || 0);
                    const snapDelta = Math.abs(cur - animTo);

                    if (snapDelta > 8) { // threshold in pixels - tweak if you want more/less sensitivity
                        // quick smooth snap (180ms)
                        await animateProperty(180, (easedP) => {
                            // animateProperty already passes eased progress; use it linearly here as interpolation factor
                            preview.hOffset = cur + (animTo - cur) * easedP;
                            updatePreviewTransform();
                        });
                    } else {
                        // tiny difference — just set immediately
                        preview.hOffset = animTo;
                        updatePreviewTransform();
                    }
                }


                // ensure blink hidden
                hideBlink();

                if (!recordState.replaying) break;

                // after horizontal pan, compute vertical target using the saved initial vOffset baseline
                const baselineV = init ? (typeof init.vOffset !== 'undefined' ? init.vOffset : preview.vOffset) : preview.vOffset;
                const deltaY = (seg.ydownPercent || 0) / 100 * preview.containerH;
                // compute max vertical based on current scale and rotation
                const imgHeightScaled = ((preview.rotation % 180) !== 0 ? preview.imgW : preview.imgH) * preview.scale;
                const maxV = Math.max(0, imgHeightScaled - preview.containerH);
                const targetV = clamp(baselineV + deltaY, 0, maxV);



                // show paused text and WAIT for user to tap/click to continue to next row (manual trigger)
                // BUT if autoplayback is enabled, skip the manual wait and continue automatically.
                if (fileSettings.autoplayback) {
                    // do not pause — just briefly show 'auto' status and continue
                    setRecTimerText('auto', 'replay');
                    // small natural pause of 150ms so UI updates are visible (optional)
                    await new Promise(r => setTimeout(r, 150));
                } else {
                    setRecTimerText('paused', 'paused');
                    // allow user interaction while waiting
                    recordState.pausedReplay = true;
                    // snapshot current segment state so resume can use it
                    // show optional hint (no-op if no hint element)
                    const hintEl = document.getElementById('hint');
                    if (hintEl) hintEl.hidden = false;

                    // wait for user action (pointerdown on preview/view or key)
                    await new Promise(resolve => {
                        function userContinueHandler(ev) {
                            try { ev.stopPropagation(); ev.preventDefault(); } catch (e) { }
                            // tell the shared resolver this was a real user action
                            if (recordState._resolveManualContinue) {
                                recordState._resolveManualContinue(true);
                            } else {
                                previewCanvas.removeEventListener('pointerdown', userContinueHandler);
                                viewCanvas.removeEventListener('pointerdown', userContinueHandler);
                                document.removeEventListener('keydown', keyHandler);
                            }
                            // cleanup and resolve
                            previewCanvas.removeEventListener('pointerdown', userContinueHandler);
                            viewCanvas.removeEventListener('pointerdown', userContinueHandler);
                            document.removeEventListener('keydown', keyHandler);
                            recordState._resolveManualContinue = null;
                            // restore paused flag
                            recordState.pausedReplay = false;
                            resolve();
                        }
                        function keyHandler(ev) {
                            if (ev.key === 'Enter' || ev.key === ' ') {
                                userContinueHandler(ev);
                            }
                        }
                        previewCanvas.addEventListener('pointerdown', userContinueHandler);
                        viewCanvas.addEventListener('pointerdown', userContinueHandler);
                        document.addEventListener('keydown', keyHandler);
                        // also keep a shared resolver so other parts can resume programmatically
                        recordState._resolveManualContinue = () => {
                            previewCanvas.removeEventListener('pointerdown', userContinueHandler);
                            viewCanvas.removeEventListener('pointerdown', userContinueHandler);
                            document.removeEventListener('keydown', keyHandler);
                            recordState._resolveManualContinue = null;
                            recordState.pausedReplay = false;
                            resolve();
                        };
                        // If a programmatic auto-continue was requested earlier (e.g. double-tap), resolve immediately.
                        if (recordState.replayController && recordState.replayController.autoContinueRequested) {
                            try { recordState._resolveManualContinue(); } catch (e) { /* ignore */ }
                            recordState.replayController.autoContinueRequested = false;
                        }

                    });
                }



                // hide when not revealing
                if (document.getElementById('previewRevealLine')) {
                    document.getElementById('previewRevealLine').style.display = 'none';
                }

                // before the fade+switch, ensure the front-layer is fully revealed so the user sees the transition
                // Only auto-reveal here if the front is NOT currently awaiting an explicit user tap.
                try {
                    if (previewImgFront && previewImgFront.style.display !== 'none' && !frontAwaitingTap) {
                        previewImgFront.style.transition = 'clip-path 220ms ease';
                        previewImgFront.style.clipPath = 'inset(0 0 0 0)'; // full reveal
                        // wait for the small transition to finish
                        await new Promise(r => setTimeout(r, 240));
                        previewImgFront.style.transition = '';
                    }
                } catch (e) { /* ignore if awaiting not allowed */ }


                // do the fade+switch to next row naturally: fade 100ms, apply vOffset change, fade out 100ms
                // do the fade+switch to next row naturally: fade 100ms, apply vOffset and hOffset change if next initial exists, fade out 100ms
                // const nextInit = (initials && initials[i + 1]) ? initials[i + 1] : null;
                // await new Promise(r => {
                //     fadeCover.style.pointerEvents = 'auto';
                //     fadeCover.style.opacity = '0.9';
                //     setTimeout(() => r(), 100);
                // });
                if (nextInit) {
                    preview.scale = typeof nextInit.scale !== 'undefined' ? nextInit.scale : preview.scale;
                    preview.hOffset = typeof nextInit.hOffset !== 'undefined' ? nextInit.hOffset : preview.hOffset;
                    preview.vOffset = typeof nextInit.vOffset !== 'undefined' ? nextInit.vOffset : targetV;
                } else {
                    preview.hOffset = animTo;
                    preview.vOffset = targetV;
                }
                updatePreviewTransform();
                // await new Promise(r => {
                //     fadeCover.style.opacity = '0';
                //     setTimeout(() => { fadeCover.style.pointerEvents = 'none'; r(); }, 100);
                // });

                hideFront();

                // resume replay state
                recordState.pausedReplay = false;
                setRecTimerText('0.0s', 'replay');

                if (!recordState.replaying) break;



            }

            // finish replay
            stopReplay();
        }




        // REPLACE existing stopReplay() with this version
        function stopReplay() {
            // mark stop flags first
            recordState.replaying = false;
            recordState.pausedReplay = false;
            overlayReplay.textContent = 'Replay';
            overlayRecord.disabled = false;

            // allow user to pan/zoom again
            preview.lockZoom = false;
            preview.lockVertical = false;

            // reset timer UI
            setRecTimerText('0.0s', 'paused');

            // // hide pause button if exists
            // const btnPause = $('#overlayPause');
            // if (btnPause) {
            //     btnPause.hidden = true;
            //     btnPause.textContent = 'Pause'; // reset label so next start shows Pause
            // }

            // // hide playback controls if present
            // const pbRew_el = document.getElementById('overlayPBRew');
            // const pbFwd_el = document.getElementById('overlayPBFwd');
            // const pbWrapper = document.getElementById('overlayPBWrapper');
            // if (pbRew_el) pbRew_el.hidden = true;
            // if (pbFwd_el) pbFwd_el.hidden = true;
            // if (pbWrapper) pbWrapper.style.display = 'none';


            const btnPause = document.getElementById('overlayPause'); if (btnPause) btnPause.hidden = true; btnPause.textContent = 'Pause';
            const pbRew = document.getElementById('overlayPBRew'); if (pbRew) pbRew.hidden = true;
            const pbFwd = document.getElementById('overlayPBFwd'); if (pbFwd) pbFwd.hidden = true;
            const pbAuto = document.getElementById('overlayPBAuto'); if (pbAuto) pbAuto.style.display = 'none';



            // hide any temporary UI left over from replay
            const blink = document.getElementById('replayBlinkLine');
            if (blink) { blink.style.display = 'none'; }
            const fade = document.getElementById('replayFadeCover');
            if (fade) { fade.style.opacity = '0'; fade.style.pointerEvents = 'none'; }

            // clear and abort any replay controller flags
            if (!recordState.replayController) recordState.replayController = {};
            recordState.replayController.skipSegment = false;
            recordState.replayController.aborted = true;
            // then remove it to ensure a clean state for next start
            recordState.replayController = null;

            // cancel/resolve any outstanding manual-continue resolver to avoid hanging promises
            if (typeof recordState._resolveManualContinue === 'function') {
                try { recordState._resolveManualContinue(); } catch (e) { /* ignore */ }
                recordState._resolveManualContinue = null;
            }

            // reset replay-related flags
            recordState.replayRecalcOnResume = false;
            recordState.currentSegmentProgress = 0;

            // hide/remove reveal line if present
            try {
                const rl = document.getElementById('previewRevealLine');
                if (rl) {
                    // prefer removing to avoid stale position on next replay
                    if (rl.parentNode) rl.parentNode.removeChild(rl);
                }
            } catch (e) { /* ignore */ }

            // hide front preview and clear awaiting-tap flag
            try { hideFront(); } catch (e) { /* ignore */ }
            frontAwaitingTap = false;

            // restore preview to initial start (prefer recorded initial[0], fallback to stored start offsets)
            try {
                const initials = (fileSettings.initials || []);
                if (initials && initials.length) {
                    const init = initials[0];
                    preview.scale = (typeof init.scale !== 'undefined') ? init.scale : (fileSettings.startZoom || preview.scale);
                    preview.hOffset = (typeof init.hOffset !== 'undefined') ? init.hOffset : (Number(fileSettings.startOffsetX) || 0);
                    preview.vOffset = (typeof init.vOffset !== 'undefined') ? init.vOffset : (Number(fileSettings.startOffsetY) || 0);
                } else {
                    preview.scale = fileSettings.startZoom || fileSettings.zoom || preview.scale;
                    preview.hOffset = Number(fileSettings.startOffsetX) || 0;
                    preview.vOffset = Number(fileSettings.startOffsetY) || 0;
                }
            } catch (e) {
                // defensive: if anything fails, fall back to zeroes
                preview.hOffset = Number(fileSettings.startOffsetX) || 0;
                preview.vOffset = Number(fileSettings.startOffsetY) || 0;
            }

            // force transform update so user immediately sees the reset position
            updatePreviewTransform(true);

            showui();
        }




        // ------------------ ADD: double-tap / double-click to skip-to-next-row during replay ------------------
        // Right-half double trigger: removes reveal line, hides front and forces replay to skip/continue.
        (function installDoubleTrigger() {
            // small state for pointer double-tap detection
            let lastTap = 0, lastTapX = 0, lastTapY = 0;
            const DOUBLE_MS = 350;   // max ms between taps
            const MAX_MOVE_PX = 50;  // allow small positional tolerance

            function isRightHalf(el, clientX) {
                const r = el.getBoundingClientRect();
                const x = clientX - r.left;
                return x >= (r.width / 2);
            }

            async function doDoubleAction(ev, el) {
                if (!recordState || !recordState.replaying) return; // only during replay

                // ensure right-half
                if (!isRightHalf(el, ev.clientX)) return;

                // remove reveal line if exists
                try {
                    const rl = document.getElementById('previewRevealLine');
                    if (rl && rl.parentNode) rl.parentNode.removeChild(rl);
                } catch (e) { /* ignore */ }

                // hide front immediately
                try { hideFront(); } catch (e) { /* ignore */ }

                // ensure replayController exists
                if (!recordState.replayController) recordState.replayController = {};

                // Create/get fadeCover
                let fadeCover = document.getElementById('replayFadeCover');
                if (!fadeCover) {
                    fadeCover = document.createElement('div');
                    fadeCover.id = 'replayFadeCover';
                    fadeCover.style.position = 'fixed';
                    fadeCover.style.left = '0';
                    fadeCover.style.top = '0';
                    fadeCover.style.width = '100%';
                    fadeCover.style.height = '100%';
                    fadeCover.style.background = '#000';
                    fadeCover.style.pointerEvents = 'none';
                    fadeCover.style.zIndex = 999998;
                    fadeCover.style.opacity = '0';
                    fadeCover.style.transition = 'opacity 100ms linear'; // 100ms fade
                    document.body.appendChild(fadeCover);
                }

                // Fade to black (100ms)
                try { fadeCover.style.opacity = '1'; } catch (e) { /* ignore */ }
                await new Promise(r => setTimeout(r, 120)); // wait slightly >100ms to be safe

                // Decide behaviour depending on whether we are currently in delay or panning
                const inDelay = !!(recordState.replayController && recordState.replayController.inDelay);

                if (inDelay) {
                    // If we are in the 'delay' phase, DO NOT set skipSegment.
                    // Instead mark a request to advance to the next row but **respect the delay**.
                    recordState.replayController.requestAdvanceRow = true;
                    recordState.replayController.forceRespectDelay = true;
                } else {
                    // If we are currently panning (duration active), we want to interrupt the pan and
                    // immediately start the flow to next row — keep the existing skip behavior.
                    recordState.replayController.skipSegment = true;
                }

                // Also mark that a programmatic "continue" was requested so any manual-wait resolves.
                recordState.replayController.autoContinueRequested = true;
                if (typeof recordState._resolveManualContinue === 'function') {
                    try { recordState._resolveManualContinue(); } catch (e) { /* ignore */ }
                    recordState._resolveManualContinue = null;
                    recordState.replayController.autoContinueRequested = false;
                }

                // Pick next initial and jump to it immediately (the jump happens under black)
                try {
                    const nextInit = (function pickNextInit() {
                        if (!recordState || !Array.isArray(recordState.initials)) return null;
                        const curIdx = (typeof recordState.segmentIndex === 'number') ? recordState.segmentIndex : -1;
                        if (recordState.initials[curIdx + 1]) return recordState.initials[curIdx + 1];
                        if (recordState.initials[curIdx]) return recordState.initials[curIdx];
                        return recordState.initials[0] || null;
                    })();

                    if (nextInit) {
                        preview.scale = (typeof nextInit.scale !== 'undefined') ? nextInit.scale : preview.scale;
                        preview.hOffset = (typeof nextInit.hOffset !== 'undefined') ? nextInit.hOffset : preview.hOffset || 0;
                        preview.vOffset = (typeof nextInit.vOffset !== 'undefined') ? nextInit.vOffset : preview.vOffset || 0;
                        try { updatePreviewTransform(); } catch (e) { /* ignore */ }
                    }
                } catch (err) {
                    console.warn('double-trigger: jump-to-next-initial failed', err);
                }

                // reveal after 200ms (per your request)
                setTimeout(() => {
                    try { fadeCover.style.opacity = '0'; } catch (e) { /* ignore */ }

                    // Clear requestAdvanceRow flag after we've applied the jump (so the replay loop can handle it)
                    if (recordState.replayController) {
                        recordState.replayController.requestAdvanceRow = false;
                        // don't clear forceRespectDelay here; let the replay loop observe it for the upcoming delay.
                    }

                    // ensure previewRevealLine doesn't remain hidden unexpectedly (some flows re-create it)
                    try {
                        let rl = document.getElementById('previewRevealLine');
                        if (rl) rl.style.display = '';
                    } catch (e) { /* ignore */ }
                }, 200);
            }


            // dblclick for mouse users (simple)
            previewCanvas.addEventListener('dblclick', (e) => { doDoubleAction(e, previewCanvas); });
            viewCanvas.addEventListener('dblclick', (e) => { doDoubleAction(e, viewCanvas); });

            // pointerdown-based double-tap detection for touch (keeps it passive-friendly)
            previewCanvas.addEventListener('pointerdown', (e) => {
                // allow event to proceed normally for non-replay states; we only want to handle during replay
                const now = performance.now();
                const rect = previewCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                if (now - lastTap < DOUBLE_MS && Math.hypot(x - lastTapX, y - lastTapY) < MAX_MOVE_PX) {
                    // double-tap detected
                    doDoubleAction(e, previewCanvas);
                    lastTap = 0;
                } else {
                    lastTap = now; lastTapX = x; lastTapY = y;
                }
            }, { passive: true });

            // and same for viewCanvas
            viewCanvas.addEventListener('pointerdown', (e) => {
                const now = performance.now();
                const rect = viewCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                if (now - lastTap < DOUBLE_MS && Math.hypot(x - lastTapX, y - lastTapY) < MAX_MOVE_PX) {
                    doDoubleAction(e, viewCanvas);
                    lastTap = 0;
                } else {
                    lastTap = now; lastTapX = x; lastTapY = y;
                }
            }, { passive: true });

        })();
        // ------------------ END ADD ---------------------------------------------------------------------------

        // ------------------ ADD: keyboard / laser-pointer support (updated: PageUp/PageDown) ------------------
        // Keys:
        //  - Enter / ArrowRight / ArrowDown / PageDown => act like double-click/tap on RIGHT half (skip / next-row / start when idle)
        //  - Space / PageUp => act like Pause/Resume (clicks overlayPause)
        // Behavior:
        //  - During replay: Enter/Right/Down/PageDown => send dblclick to preview/view (right half) to trigger same flow
        //  - During replay: Space/PageUp => toggle pause/resume (click overlayPause)
        //  - Not replaying and not recording: Enter/Right/Down/PageDown => click Replay button (start replay)
        //  - Ignore when user types into inputs/textareas/contenteditable
        document.addEventListener('keydown', function (ev) {
            try {
                // ignore if user is typing
                const active = document.activeElement;
                if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;

                const key = ev.key;
                // normalize Space (some browsers give ' ' for space key)
                const isSpace = (key === ' ' || key === 'Spacebar' || ev.code === 'Space' || key === 'Space');
                const isPageUp = (key === 'PageUp');
                const isPageDown = (key === 'PageDown');

                // SPACE or PAGE UP: toggle pause/resume by clicking existing overlayPause button (if visible)
                if (isSpace || isPageUp) {
                    ev.preventDefault();
                    const btnPause = document.getElementById('overlayPause');
                    if (btnPause && !btnPause.hidden) {
                        btnPause.click();
                        return;
                    }
                    // fallback behavior similar to previous snippet
                    if (typeof recordState !== 'undefined' && recordState && recordState.replaying) {
                        recordState.pausedReplay = !recordState.pausedReplay;
                        setRecTimerText && setRecTimerText(recordState.pausedReplay ? 'Paused' : '0.0s', recordState.pausedReplay ? 'paused' : 'replay');
                    } else if (typeof viewPage !== 'undefined' && viewPage && viewPage.style.display === 'block') {
                        // if we're in view mode, toggle play/pause there if function exists
                        typeof togglePlayPause === 'function' && togglePlayPause();
                    }
                    return;
                }

                // Enter / Right / Down / PageDown => act like right-half double-tap
                if (key === 'Enter' || key === 'ArrowRight' || key === 'ArrowDown' || isPageDown) {
                    ev.preventDefault();

                    // If we are actively replaying -> dispatch a dblclick on the right half of the visible canvas
                    if (typeof recordState !== 'undefined' && recordState && recordState.replaying) {
                        // pick the active canvas (view has priority if visible)
                        const target = (typeof viewPage !== 'undefined' && viewPage && viewPage.style.display === 'block') ? viewCanvas : previewCanvas;
                        if (target) {
                            const rect = target.getBoundingClientRect();
                            // pick a point well inside the right half (80% from left)
                            const cx = Math.round(rect.left + rect.width * 0.8);
                            const cy = Math.round(rect.top + rect.height * 0.5);
                            // create and dispatch a synthetic dblclick — the existing dblclick listener will call same flow
                            const dbl = new MouseEvent('dblclick', {
                                bubbles: true,
                                cancelable: true,
                                view: window,
                                clientX: cx,
                                clientY: cy,
                                button: 0
                            });
                            target.dispatchEvent(dbl);
                            return;
                        }
                    }

                    // Not replaying / not recording: pressing Enter/Right/Down/PageDown should start replay (click overlayReplay)
                    if (!(typeof recordState !== 'undefined' && recordState && recordState.mode === 'recording')) {
                        const replayBtn = document.getElementById('overlayReplay') || document.getElementById('overlayReplayBtn');
                        if (replayBtn && !replayBtn.hidden) {
                            replayBtn.click();
                            return;
                        }
                    }
                }
            } catch (err) {
                // silent fallback — do not block user experience on errors
                console.warn('keyboard handler error', err);
            }
        }, { passive: false });
        // ------------------ END ADD ------------------------------------------------


        // overlayReplay click handler (toggle start/stop)
        if (overlayReplay) {

            overlayReplay.addEventListener('click', () => {
                if (recordState.replaying) {
                    stopReplay();
                } else {
                    startReplay();
                }
            });
        }

        // overlay pause (toggle pause/resume)
        // Replace existing overlayPause click handler with this:
        document.addEventListener('click', (e) => {
            if (!(e.target && e.target.id === 'overlayPause')) return;

            // toggle paused state
            recordState.pausedReplay = !recordState.pausedReplay;
            const btn = e.target;
            btn.textContent = recordState.pausedReplay ? 'Lanjut' : 'Pause';

            if (recordState.pausedReplay) {
                // PAUSED: allow user panning (both horizontal & vertical), but keep zoom locked
                preview.lockZoom = true;
                preview.lockVertical = false; // allow both horizontal & vertical pans
                // un-block input: isReplayActive() will now return false because pausedReplay=true
                setRecTimerText('paused', 'replay');
            } else {
                // RESUMED: re-lock pans (both horizontal and vertical locked during replay)
                // we will recalculate which segment to continue from
                preview.lockZoom = true;
                preview.lockVertical = true;

                // prepare controller to skip the current running animation and jump into recalculation
                if (!recordState.replayController) recordState.replayController = { skipSegment: false, aborted: false };
                // set skip flag to abort any current animateProperty loop immediately; the main loop will then recalc

                recordState.replayRecalcOnResume = true;   // just recalc, do NOT skip
                recordState.replayController.skipSegment = false;  // ensure no skip happens                

                // update UI
                setRecTimerText('0.0s', 'replay');
            }
        });


        // ensure overlayReplay visibility on load if segments exist
        try { overlayReplay.hidden = !(fileSettings.segments && fileSettings.segments.length); } catch (e) { }


        if (btnViewToggle) {
            btnViewToggle.addEventListener('click', () => {
                togglePlayPause();
            });
        }

        function backToSetup() {
            // stop any running animation / timers and set state to "Ready"
            stopAllPlaying();

            // copy current view state back into preview/file settings so preview shows what user last saw
            preview.scale = viewState.scale;
            preview.hOffset = viewState.hOffset;
            preview.vOffset = viewState.vOffset;
            preview.rotation = viewState.rotation;

            // ensure preview image src is set (defensive)
            if (viewImg && viewImg.src && (!previewImg || !previewImg.src)) {
                previewImg.src = viewImg.src;
            }

            // unlock preview interactions
            preview.lockVertical = false;
            preview.lockZoom = false;

            // hide view, show setup
            viewPage.style.display = 'none';
            viewPage.setAttribute('aria-hidden', 'true');
            const setupPage = $('#setupPage');
            setupPage.style.display = 'flex';

            // force recompute container dims and redraw preview
            updatePreviewTransform(true);

            // persist loaded settings
            saveRecord();

            // show replay only if both segments and initials exist for this file
            try {
                overlayReplay.hidden = !(fileSettings.segments && fileSettings.segments.length && fileSettings.initials && fileSettings.initials.length);
            } catch (e) {
                overlayReplay.hidden = true;
            }

        }



        if (btnViewBack) {
            btnViewBack.addEventListener('click', backToSetup);
        }


        // ======= Open view (enter view) =======
        btnOpenView.addEventListener('click', () => {
            if (!currentFile) return alert('No file loaded');
            fileSettings.duration = Number(inpDuration.value) || DEFAULTS.duration;
            fileSettings.delay = Number(inpDelay.value) || DEFAULTS.delay;
            fileSettings.ydownPercent = Number(inpYdown.value) || DEFAULTS.ydownPercent;
            if (!fileSettings.startZoom) fileSettings.startZoom = preview.scale;
            enterView();
        });

        // ======= Update preview on image load / resize =======
        previewImg.onload = () => updatePreviewTransform(true);
        window.addEventListener('resize', () => updatePreviewTransform(true));

        // ======= View page logic (modified) =======
        function updateViewPauseButtonLabel() {
            if (!btnViewToggle) return;
            btnViewToggle.textContent = (viewState.state === 'Playing') ? 'Pause' : 'Play';
        }

        // helper to recalc dims for view (also used after rotate)
        function enterView_recalcAndApply() {
            const rect = viewCanvas.getBoundingClientRect();
            viewState.containerW = rect.width; viewState.containerH = rect.height;
            viewState.imgW = preview.imgW; viewState.imgH = preview.imgH;
            viewState.startZoom = fileSettings.startZoom || fileSettings.zoom || preview.scale || 1;
            viewState.scale = viewState.startZoom;
            viewState.startOffsetX = Number(fileSettings.startOffsetX) || 0;
            viewState.startOffsetY = Number(fileSettings.startOffsetY) || 0;
            viewState.duration = Number(fileSettings.duration) || DEFAULTS.duration;
            viewState.delay = Number(fileSettings.delay) || DEFAULTS.delay;
            viewState.ydownPercent = Number(fileSettings.ydownPercent) || DEFAULTS.ydownPercent;
            // rotation from preview
            viewState.rotation = preview.rotation || 0;
            // if rotation 90/270 swap dims
            const is90 = (viewState.rotation % 180) !== 0;
            const scaledW = (is90 ? viewState.imgH : viewState.imgW) * viewState.scale;
            const scaledH = (is90 ? viewState.imgW : viewState.imgH) * viewState.scale;
            viewState.D_x = Math.max(0, scaledW - viewState.containerW);
            viewState.D_y = Math.max(0, scaledH - viewState.containerH);
            viewState.startOffsetX = clamp(viewState.startOffsetX, 0, viewState.D_x);
            viewState.startOffsetY = clamp(viewState.startOffsetY, 0, viewState.D_y);
            viewState.hOffset = viewState.startOffsetX;
            viewState.vOffset = viewState.startOffsetY;
            // compute vx as full-travel / duration (for use when resuming)
            const travelX = Math.max(0, viewState.D_x - viewState.startOffsetX);
            viewState.vx = travelX <= 0 ? 0 : travelX / viewState.duration;
            // apply transform
            viewImg.style.transform = `translate3d(${-viewState.hOffset}px, ${-viewState.vOffset}px, 0) rotate(${viewState.rotation}deg) scale(${viewState.scale})`;
        }

        // enter view (now starts in Paused so user can pan initial)
        function enterView() {
            $('#setupPage').style.display = 'none';
            viewPage.style.display = 'flex';
            viewPage.setAttribute('aria-hidden', 'false');

            enterView_recalcAndApply();  // <-- now canvas is visible

            viewState.state = 'Paused';
            updateStatePill('Paused');
            updateViewPauseButtonLabel();

            if (viewState.playReqId) cancelAnimationFrame(viewState.playReqId);
            viewState.playReqId = null;
        }


        // Update state label
        function updateStatePill(text) { statePill.textContent = text; }

        // Apply transform with optional transition, always clamp offsets
        function applyViewTransform(transition = false) {
            // recalc current scaled dims based on rotation & scale
            const rot = ((viewState.rotation % 360) + 360) % 360;
            const is90 = (rot === 90 || rot === 270);
            const scaledW = (is90 ? viewState.imgH : viewState.imgW) * viewState.scale;
            const scaledH = (is90 ? viewState.imgW : viewState.imgH) * viewState.scale;
            viewState.D_x = Math.max(0, scaledW - viewState.containerW);
            viewState.D_y = Math.max(0, scaledH - viewState.containerH);
            viewState.hOffset = clamp(viewState.hOffset, 0, viewState.D_x);
            viewState.vOffset = clamp(viewState.vOffset, 0, viewState.D_y);
            if (transition) { viewImg.style.transition = 'transform 320ms ease'; setTimeout(() => viewImg.style.transition = '', 360); }
            viewImg.style.transform = `translate3d(${-Math.round(viewState.hOffset)}px, ${-Math.round(viewState.vOffset)}px, 0) rotate(${viewState.rotation}deg) scale(${viewState.scale})`;
        }

        // View pointer handlers (dragging when paused)
        let viewActivePointers = new Map();
        viewCanvas.addEventListener('pointerdown', (e) => {
            viewCanvas.setPointerCapture(e.pointerId);
            viewActivePointers.set(e.pointerId, e);
            if (viewActivePointers.size === 1) {
                viewState._dragging = true;
                viewState._lastPointer = { x: e.clientX, y: e.clientY };
            }
        });
        viewCanvas.addEventListener('pointermove', (e) => {
            if (!viewActivePointers.has(e.pointerId)) return;
            viewActivePointers.set(e.pointerId, e);
            if (viewActivePointers.size === 1 && viewState._dragging) {
                const p = viewState._lastPointer;
                const dx = e.clientX - p.x, dy = e.clientY - p.y;
                viewState._lastPointer = { x: e.clientX, y: e.clientY };
                if (viewState.state === 'Paused') {
                    viewState.hOffset = clamp(viewState.hOffset - dx, 0, viewState.D_x);
                    viewState.vOffset = clamp(viewState.vOffset - dy, 0, viewState.D_y);
                    applyViewTransform();
                    updateStatePill('Paused');
                }
            }
        });
        viewCanvas.addEventListener('pointerup', (e) => { if (viewActivePointers.has(e.pointerId)) { viewCanvas.releasePointerCapture(e.pointerId); } viewActivePointers.delete(e.pointerId); if (viewActivePointers.size === 0) { viewState._dragging = false; viewState._lastPointer = null; } });
        viewCanvas.addEventListener('pointercancel', (e) => { viewActivePointers.delete(e.pointerId); viewState._dragging = false; viewState._lastPointer = null; });

        // click handler for starting/controls/atEnd (use click to avoid interfering with drag)
        viewCanvas.addEventListener('click', (e) => {
            if (viewState._dragging) return;
            const rect = viewCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const half = rect.width / 2;
            if (viewState.state === 'Ready' || viewState.state === 'Paused') {
                // If paused and user clicked/tapped center, we'll treat it as resume (toggle)
                if (viewState.state === 'Paused') {
                    // if clicking center, call resume logic
                    if (approxEqual(viewState.hOffset, viewState.startOffsetX, 1)) {
                        // if at initial X, wait for delay then start
                        updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
                        if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
                        viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
                    } else {
                        // not initial X: compute remaining seconds using vx and start immediately
                        startPlaying();
                    }
                } else {
                    // was Ready (edge case) -> start waiting
                    viewState.state = 'WaitingDelay';
                    updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
                    if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
                    viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
                }
            } else if (viewState.state === 'AtEndAwaitingTrigger') {
                if (x >= half) handleEndTapRight(); else handleEndTapLeft();
            }
        });

        // Pause/Resume control is just double-tap in UI; we provide no separate buttons in view for simplicity
        // But we'll attach keyboard fallback (for debugging)
        document.addEventListener('keydown', (e) => { if (e.key === ' ') { if (viewState.state === 'Playing') pausePlaying(); else if (viewState.state === 'Paused') { startPlaying(); } } });



        // Playing loop functions (start/pause/resume/stop)
        function startPlaying() {
            // compute vx if zero
            const totalTravel = Math.max(0.0001, viewState.D_x - viewState.startOffsetX);
            // If vx is zero (means not computed or changed), compute from duration
            if (!viewState.vx || viewState.vx === 0) {
                viewState.vx = totalTravel / (viewState.duration || DEFAULTS.duration);
            }
            viewState.state = 'Playing';
            viewState._playStartTimestamp = performance.now();
            viewState._hOffsetAtPlayStart = viewState.hOffset;
            if (viewState.playReqId) cancelAnimationFrame(viewState.playReqId);
            viewState.playReqId = requestAnimationFrame(viewLoop);
            updateStatePill('Playing');
        }

        function viewLoop() {
            if (viewState.state !== 'Playing') return;
            const elapsed = (performance.now() - viewState._playStartTimestamp) / 1000;
            const newH = Math.min(viewState.D_x, viewState._hOffsetAtPlayStart + viewState.vx * elapsed);
            viewState.hOffset = newH;
            applyViewTransform();
            const travelTot = Math.max(1, viewState.D_x - viewState.startOffsetX);
            const progress = Math.round(((viewState.hOffset - viewState.startOffsetX) / travelTot) * 100);
            updateStatePill('Playing ' + Math.max(0, Math.min(100, progress)) + '%');
            if (viewState.hOffset >= viewState.D_x - 0.5) {
                viewState.hOffset = viewState.D_x;
                applyViewTransform();
                viewState.state = 'AtEndAwaitingTrigger';
                updateStatePill('At End');
                return;
            }
            viewState.playReqId = requestAnimationFrame(viewLoop);
        }

        function togglePlayPause() {
            if (viewState.state === 'Playing') {
                // go to Paused at current position
                pausePlaying();
            } else if (viewState.state === 'Paused') {
                // smart resume (uses startOffsetX vs current hOffset)
                resumePlaying();
            } else if (viewState.state === 'WaitingDelay') {
                // cancel pending delay and stay paused
                if (viewState._delayTimeout) {
                    clearTimeout(viewState._delayTimeout);
                    viewState._delayTimeout = null;
                }
                viewState.state = 'Paused';
                updateStatePill('Paused');
            } else {
                // from Ready / AtEnd / other -> start from beginning
                startPlaying();
            }
            updateViewPauseButtonLabel();
        }

        function pausePlaying() {
            if (viewState.state !== 'Playing') return;
            const elapsed = (performance.now() - viewState._playStartTimestamp) / 1000;
            viewState.hOffset = Math.min(viewState.D_x, viewState._hOffsetAtPlayStart + viewState.vx * elapsed);
            if (viewState.playReqId) cancelAnimationFrame(viewState.playReqId);
            viewState.state = 'Paused';
            applyViewTransform();
            updateStatePill('Paused');
        }

        function resumePlaying() {
            if (viewState.state !== 'Paused') return;
            // if current x equals startOffsetX within tolerance -> add delay
            if (approxEqual(viewState.hOffset, viewState.startOffsetX, 1)) {
                updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
                if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
                viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
            } else {
                // start playing immediately — vx already holds speed computed earlier
                viewState._hOffsetAtPlayStart = viewState.hOffset;
                viewState._playStartTimestamp = performance.now();
                viewState.state = 'Playing';
                viewState.playReqId = requestAnimationFrame(viewLoop);
                updateStatePill('Playing');
            }
        }

        function stopAllPlaying() {
            if (viewState._delayTimeout) { clearTimeout(viewState._delayTimeout); viewState._delayTimeout = null; }
            if (viewState.playReqId) { cancelAnimationFrame(viewState.playReqId); viewState.playReqId = null; }
            viewState.state = 'Ready';
            updateStatePill('Ready');
        }

        // End tap handlers (unchanged behavior but clamped)
        function handleEndTapRight() {
            // if both at end horizontally and vertically -> reset to start and play next (original behavior)
            if (Math.abs(viewState.hOffset - viewState.D_x) < 1 && Math.abs(viewState.vOffset - viewState.D_y) < 1) {
                viewState.hOffset = viewState.startOffsetX;
                viewState.vOffset = viewState.startOffsetY;
                viewState.scale = viewState.startZoom;
                applyViewTransform(true);
                viewState.state = 'WaitingDelay';
                updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
                if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
                viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
            } else {
                const deltaY = viewState.containerH * (viewState.ydownPercent / 100);
                const scaledH = ((viewState.rotation % 180) !== 0 ? viewState.imgW : viewState.imgH) * viewState.scale;
                viewState.D_y = Math.max(0, scaledH - viewState.containerH);
                viewState.vOffset = clamp(viewState.vOffset + deltaY, 0, viewState.D_y);
                viewState.hOffset = viewState.startOffsetX;
                applyViewTransform(true);
                viewState.state = 'WaitingDelay';
                updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
                if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
                viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
            }
        }

        function handleEndTapLeft() {
            const deltaY = viewState.containerH * (viewState.ydownPercent / 100);
            const scaledH = ((viewState.rotation % 180) !== 0 ? viewState.imgW : viewState.imgH) * viewState.scale;
            viewState.D_y = Math.max(0, scaledH - viewState.containerH);
            viewState.vOffset = clamp(viewState.vOffset - deltaY, 0, viewState.D_y);
            viewState.hOffset = viewState.startOffsetX;
            applyViewTransform(true);
            viewState.state = 'WaitingDelay';
            updateStatePill('Waiting: ' + viewState.delay.toFixed(1) + 's');
            if (viewState._delayTimeout) clearTimeout(viewState._delayTimeout);
            viewState._delayTimeout = setTimeout(() => startPlaying(), Math.max(0, viewState.delay) * 1000);
        }

        // Back to setup page (we use an overlay click on the View page to go back — easiest is to click view area with two fingers or use escape)
        viewPage.addEventListener('dblclick', () => { stopAllPlaying(); viewPage.style.display = 'none'; $('#setupPage').style.display = 'flex'; updateStatePill('Ready'); });

        // ======= Initialization & last file restore =======
        async function appInit() {
            inpDuration.value = localStorage['partitur:defaultDuration'] || DEFAULTS.duration;
            inpDelay.value = localStorage['partitur:defaultDelay'] || DEFAULTS.delay;
            inpYdown.value = localStorage['partitur:defaultYdown'] || DEFAULTS.ydownPercent;
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_FILES, 'readonly'); const st = tx.objectStore(STORE_FILES);
                let latest = null;
                st.openCursor().onsuccess = async e => {
                    const cur = e.target.result;
                    if (cur) { if (cur.value && cur.value.lastUsed && (!latest || cur.value.lastUsed > latest.lastUsed)) latest = cur.value; cur.continue(); } else {
                        if (latest && latest.handle) {
                            try { const ok = await verifyFileHandlePermission(latest.handle); if (ok) { const f = await latest.handle.getFile(); await loadFile(f, latest.handle); } } catch (err) { console.warn('reopen fail', err); }
                        }
                    }
                };
            } catch (err) { console.warn('init error', err); }
        }

        async function verifyFileHandlePermission(handle) {
            if (!handle) return false;
            try {
                if (handle.queryPermission) {
                    const q = await handle.queryPermission({ mode: 'read' });
                    if (q === 'granted') return true;
                }
                if (handle.requestPermission) {
                    const r = await handle.requestPermission({ mode: 'read' });
                    return r === 'granted';
                }
            } catch (e) { return false; }
            return true;
        }

        appInit().catch(e => console.warn(e));

        // save UI default changes
        inpDuration.addEventListener('change', () => localStorage['partitur:defaultDuration'] = inpDuration.value);
        inpDelay.addEventListener('change', () => localStorage['partitur:defaultDelay'] = inpDelay.value);
        inpYdown.addEventListener('change', () => localStorage['partitur:defaultYdown'] = inpYdown.value);

        // // update start label when preview changes (debounce)
        // function refreshStartLabelDebounced(){
        //   setTimeout(()=> updateStartLabel(), 150);
        // }
        // updateStartLabel();

        // ensure preview dims update
        window.addEventListener('resize', () => { updatePreviewTransform(true); if (viewPage.style.display === 'block') enterView_recalcAndApply(); });
        previewImg.onload = () => { updatePreviewTransform(true); if (viewPage.style.display === 'block') enterView_recalcAndApply(); };

    </script>
    <script>
        /* small script to enforce styles at runtime and hide view button if created dynamically */
        (function () {
            // hide view button (defensive - supports multiple possible selectors)
            const viewSelectors = ['#viewButton', '.view-button', '.btn-view', '.viewBtn'];
            viewSelectors.forEach(s => {
                const el = document.querySelector(s);
                if (el) el.style.display = 'none';
            });

            // ensure zoom label color reflects the CSS variable (useful if label text set after load)
            const setZoomLabelColor = () => {
                const label = document.getElementById('zoomLabel') || document.querySelector('.zoom-value') || document.querySelector('label[for="zoomSlider"]');
                if (!label) return;
                // read the CSS var (fallback to the same hex)
                const uiBlue = getComputedStyle(document.documentElement).getPropertyValue('--ui-blue') || '#1e90ff';
                label.style.color = uiBlue.trim();
                label.style.fontWeight = '600';
            };

            // On DOM ready and when new content might be injected
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setZoomLabelColor);
            } else {
                setZoomLabelColor();
            }

            // If your app updates zoom label dynamically, call setZoomLabelColor() after updates.
            // e.g. after setting label text: document.getElementById('zoomLabel').textContent = '200%'; setZoomLabelColor();
        })();


        /* --- WELCOME OVERLAY --- */
        window.addEventListener('DOMContentLoaded', function installWelcomeOverlay() {
            // only once
            if (document.getElementById('welcomeOverlay')) return;
        
            const message = `
        
        Cara penggunaan:
        1. Load: untuk membuka partitur (image) dari salah satu sumber (local, url, cloud)
        2. Record: dilakukan satu kali untuk merekam pergerakan layar saat membaca partitur
        3. Replay: tombol tersedia apabila partitur tersebut pernah dilakukan record.
        
        Catatan, untuk hasil yang terbaik:
        - orientasi record dan replay landscape
        - lakukan record dan replay pada perangkat yang sama / ukuran layar yang sama.
        `;
        
        const html = `
            <div id="welcomeOverlay" aria-hidden="false" style="
                position:fixed;
                inset:0;
                z-index:10000000;
                display:flex;
                align-items:center;
                justify-content:center;
                background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.8));
                -webkit-backdrop-filter: blur(4px);
                        backdrop-filter: blur(4px);
            ">
                <div role="dialog" aria-label="Welcome" style="
                max-width:980px;
                width:calc(100% - 40px);
                margin:20px;
                background:linear-gradient(180deg,#ffffff,#f6f8ff);
                color:#071127;
                border-radius:12px;
                padding:0; /* keep padding inside children for better scroll behavior */
                box-shadow:0 20px 40px rgba(0,0,0,0.45);
                text-align:left;
                line-height:1.45;
                box-sizing:border-box;
                display:flex;
                flex-direction:column;
                max-height: calc(100vh - 40px);
                overflow: hidden;
                ">
                <!-- Header -->
                <div style="padding:20px 22px 8px;">
                    <h2 style="margin:0 0 6px; font-size:1.4rem; color:#06336b; text-align:center;">Aplikasi BACA PARTITUR</h2>
                </div>

                <!-- Scrollable message area -->
                <div id="welcomeContent" style="
                    padding:0 22px 12px;
                    overflow:auto;
                    flex:1;
                    min-height:0; /* essential for flex scroll to work on some browsers */
                ">
                    <pre style="white-space:pre-wrap; font-family:inherit; font-size:0.98rem; margin:0; color:#0b2540;">${message}</pre>
                </div>

                <!-- Footer with Load button always visible -->
                <div style="padding:14px 22px 22px; display:flex; justify-content:center; border-top: 1px solid rgba(6,51,107,0.06); background:linear-gradient(180deg, rgba(255,255,255,0.0), rgba(255,255,255,0.03));">
                    <button id="welcomeLoadBtn" class="btn btn-primary" style="
                    font-size:1.05rem;
                    padding:12px 30px;
                    border-radius:12px;
                    min-width:160px;
                    font-weight:800;
                    ">Load</button>
                </div>
                </div>
            </div>`;
            
        
            // attach
            try {
            document.body.insertAdjacentHTML('beforeend', html);
            } catch (e) {
            console.warn('welcomeOverlay insert failed', e);
            return;
            }
        
            const overlay = document.getElementById('welcomeOverlay');
            const wbtn = document.getElementById('welcomeLoadBtn');
        
            // Clicking the welcome Load should trigger the same existing Load behaviour.
            // Prefer overlayLoad (the small overlay button) then fallback to btnLoad.
            wbtn.addEventListener('click', function onWelcomeLoad() {
            // Try to trigger existing Load handlers safely
            const preferred = document.getElementById('overlayLoad') || document.getElementById('btnLoad');
        
            if (preferred) {
                try {
                // trigger click programmatically (this will reuse your existing createLoadModal/openFilePicker flow)
                preferred.click();
                } catch (err) {
                console.warn('triggering existing load button failed', err);
                }
            } else {
                console.warn('No existing load button found (overlayLoad/btnLoad).');
            }
        
            // remove the welcome overlay immediately
            try { overlay.parentNode && overlay.parentNode.removeChild(overlay); } catch (e) { /* ignore */ }
            });
        
            // Prevent accidental removal by other code: keep aria-hidden false for now.
        });
        /* --- end welcome overlay --- */
          

    </script>

    <script>
    let deferredPrompt;
    const btn = document.getElementById('a2hsBtn');
    window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    btn.style.display = 'block';
    });
    btn?.addEventListener('click', async () => {
    btn.style.display = 'none';
    if (deferredPrompt) {
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    deferredPrompt = null;
    }
    });
    </script>
    <script>
    if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js')
    .then(() => console.log('Service Worker registered'))
    .catch(e => console.error('SW registration failed', e));
    }
    </script>  

</body>

</html>
